[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "IQB Methods Team",
    "section": "",
    "text": "Currently, this website hosts material for and from the R-SIG. It might be expanded later on to include general methods team related material."
  },
  {
    "objectID": "index.html#r-sig",
    "href": "index.html#r-sig",
    "title": "IQB Methods Team",
    "section": "R-SIG",
    "text": "R-SIG\n\n\n\n\n\n\nTip\n\n\n\nThe R-SIG meets each every two weeks on Monday from 13:00 - 14:00. The next meeting will be on 9.10.2023.\n\n\nIn this meeting we talk about all kind of topics related to scientific programming in R. Come along!"
  },
  {
    "objectID": "index.html#schedule",
    "href": "index.html#schedule",
    "title": "IQB Methods Team",
    "section": "Schedule",
    "text": "Schedule\n\n\n\n\n\n\n\nDate\nTopic\n\n\n\n\n9.10.2023\nImproving code: How to write clear and parsimonious code in R?"
  },
  {
    "objectID": "posts_newsletter.html",
    "href": "posts_newsletter.html",
    "title": "Newsletter",
    "section": "",
    "text": "09-08-2023\n\n\nNewsletter\n\n\n\nBenjamin Becker\n\n\nSep 8, 2023\n\n\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "posts/r_sig/23_31_07_apply/index.html",
    "href": "posts/r_sig/23_31_07_apply/index.html",
    "title": "The apply family",
    "section": "",
    "text": "I can highly recommend the according chapter in R for Data Science in case you want to dive deeper."
  },
  {
    "objectID": "posts/r_sig/23_31_07_apply/index.html#for-loops",
    "href": "posts/r_sig/23_31_07_apply/index.html#for-loops",
    "title": "The apply family",
    "section": "For-loops",
    "text": "For-loops\nIn the last SIG we talked about for-loops.\nWhile for is definitely the most flexible of the looping options, we suggest you avoid it wherever you can, for the following two reasons:\n\n\nIt is not very expressive, i.e. takes a lot of code to do what you want.\n\n\nIt permits you to write horrible code.\n\n\nLet’s consider this example:\n\nexample_list &lt;- list(\n  \"vec_1\" = c(1:10),\n  \"vec_2\" = c(100:400),\n  \"vec_3\" = c(80:97, NA)\n)\nstr(example_list)\n\nList of 3\n $ vec_1: int [1:10] 1 2 3 4 5 6 7 8 9 10\n $ vec_2: int [1:301] 100 101 102 103 104 105 106 107 108 109 ...\n $ vec_3: int [1:19] 80 81 82 83 84 85 86 87 88 89 ...\n\n\nHere we have a list consisting of three vectors. Our goal is to sum them an output the result into a new vector. We could use a for-loop to do that:\n\nvec_sum &lt;- c()\nfor(i in 1: length(example_list)){\n  vec_sum[i] &lt;- sum(example_list[[i]], na.rm = TRUE)\n}\nvec_sum\n\n[1]    55 75250  1593\n\n\nOkay, that doesn’t look that complicated. But still, we need to define an empty vector at the beginning so we can save our sums, we need to iterate from 1:length(example_list), and manually select the \\(i^{th}\\) from the input list. That is not very expressive, and can be solved a lot easier. Enter, the apply-family:"
  },
  {
    "objectID": "posts/r_sig/23_31_07_apply/index.html#the-apply-family",
    "href": "posts/r_sig/23_31_07_apply/index.html#the-apply-family",
    "title": "The apply family",
    "section": "The apply-family",
    "text": "The apply-family\nThe apply-functions apply a function to a vector, list, matrix … and also always return a vector, list matrix …, depending on the specific function. Let’s rewrite our for-loop with sapply():\n\nvec_sum &lt;- sapply(example_list, sum)\nvec_sum\n\nvec_1 vec_2 vec_3 \n   55 75250    NA \n\n\nA lot less code and easier to understand! We just go over every list element and calculate its sum.\nIf we want to add another function argument, we can do that as well:\n\nvec_sum &lt;- sapply(example_list, sum, na.rm = TRUE)\nvec_sum\n\nvec_1 vec_2 vec_3 \n   55 75250  1593 \n\n\nWe can also define our own function:\n\nvec_sum &lt;- sapply(example_list, function(x){\n  res_sum &lt;- sum(x, na.rm = TRUE)\n  print(res_sum)\n  return(res_sum)\n})\n\n[1] 55\n[1] 75250\n[1] 1593\n\n\nHere we calculate the sum of object x, and then print it.\nFinally, which makes for even nicer code, we can define the function externally, to give it a concise name:\n\nprint_sum &lt;- function(vec){\n  res_sum &lt;- sum(vec, na.rm = TRUE)\n  print(res_sum)\n  return(res_sum)\n}\n\nvec_sum &lt;- sapply(example_list, print_sum)\n\n[1] 55\n[1] 75250\n[1] 1593\n\nvec_sum\n\nvec_1 vec_2 vec_3 \n   55 75250  1593 \n\n\nDepending of the output we want, we can choose different apply-functions:\n\nsapply()\nsapply() simplifies the result, so, e.g., it will return a vector if possible:\n\nsapply(example_list, print_sum)\n\n[1] 55\n[1] 75250\n[1] 1593\n\n\nvec_1 vec_2 vec_3 \n   55 75250  1593 \n\n\n\n\nvapply()\nSimilar to sapply(), but we can pre-specify a return value, so it might be safer to use:\n\nvapply(example_list, print_sum, integer(1))\n\n[1] 55\n[1] 75250\n[1] 1593\n\n\nvec_1 vec_2 vec_3 \n   55 75250  1593 \n\n\nBecause the result is an integer vector, we don’t get an error, but if we write this:\n\nvapply(example_list, print_sum, character(1))\n\n[1] 55\n\n\nError in vapply(example_list, print_sum, character(1)): values must be type 'character',\n but FUN(X[[1]]) result is type 'integer'\n\n\nThe function returns an error, because its output is an integer, and not a character vector.\n\n\nlapply()\nReturns a list:\n\nlapply(example_list, print_sum)\n\n[1] 55\n[1] 75250\n[1] 1593\n\n\n$vec_1\n[1] 55\n\n$vec_2\n[1] 75250\n\n$vec_3\n[1] 1593\n\n\n\n\n\n\n\n\nExercises\n\n\n\nWork with the iris data.frame (it is already included in Base R):\n\nExercise 1\nWrite a for-loop to determine the median of each column, if it is numeric. If not, return the column class with class(). Save the results in a character vector, so every element should be converted to character before saving it in the vector.\n\n\n\n\n\n\nCaution\n\n\n\n\n\n\nvec_median &lt;- c()\nfor(i in 1:ncol(iris)){\n  if(is.numeric(iris[, i])){\n    vec_median[i] &lt;- as.character(median(iris[, i], na.rm = TRUE))\n  } else{\n    vec_median[i] &lt;- class(iris[, i])\n  }\n}\n\nvec_median\n\n[1] \"5.8\"    \"3\"      \"4.35\"   \"1.3\"    \"factor\"\n\n\n\n\n\n\n\nExercise 2\n\nDefine the body of the for loop as its own function. This function should take a vector, and, if this vector is numeric, output the median as a character, otherwise the class of the vector.\n\n\n\n\n\n\n\nCaution\n\n\n\n\n\n\ncheck_median &lt;- function(vec){\n  if(is.numeric(vec)){\n    result &lt;- median(vec, na.rm = TRUE)\n  } else{\n    result &lt;- class(vec)\n  }\n  ## Convert to character, so our function always returns the correct type\n  result &lt;- as.character(result)\n  return(result)\n}\n\n## Check it:\ncheck_median(c(100, 1000))\n\n[1] \"550\"\n\ncheck_median(c(\"a\", \"b\"))\n\n[1] \"character\"\n\n\n\n\n\n\nUse it in the for-loop.\n\n\n\n\n\n\n\nCaution\n\n\n\n\n\n\nvec_median &lt;- c()\nfor(i in 1:ncol(iris)){\n  vec_median[i] &lt;- check_median(iris[, i])\n}\n\nvec_median\n\n[1] \"5.8\"    \"3\"      \"4.35\"   \"1.3\"    \"factor\"\n\n\n\n\n\n\n\nExercise 3\nRewrite the for-loop from Exercise 1 with functions from the apply-family, so it returns the following objects. Define the function that gets applied on every input element externally, so we have cleaner code.\n\nA vector.\n\n\n\n\n\n\n\nCaution\n\n\n\n\n\n\nsapply(iris, check_median)\n\nSepal.Length  Sepal.Width Petal.Length  Petal.Width      Species \n       \"5.8\"          \"3\"       \"4.35\"        \"1.3\"     \"factor\" \n\n\nOr, even better:\n\nvapply(iris, check_median, character(1))\n\nSepal.Length  Sepal.Width Petal.Length  Petal.Width      Species \n       \"5.8\"          \"3\"       \"4.35\"        \"1.3\"     \"factor\" \n\n\nWow, that’s pretty nice, we condensed our function to half a line by defining the function somewhere else, and not using a for-loop!\n\n\n\n\nA list.\n\n\n\n\n\n\n\nCaution\n\n\n\n\n\n\nlapply(iris, check_median)\n\n$Sepal.Length\n[1] \"5.8\"\n\n$Sepal.Width\n[1] \"3\"\n\n$Petal.Length\n[1] \"4.35\"\n\n$Petal.Width\n[1] \"1.3\"\n\n$Species\n[1] \"factor\""
  },
  {
    "objectID": "posts/r_sig/23_31_07_apply/index.html#exercise-2",
    "href": "posts/r_sig/23_31_07_apply/index.html#exercise-2",
    "title": "The apply family",
    "section": "Exercise 2",
    "text": "Exercise 2\n\nDefine the body of the for loop as its own function. This function should take a vector, and, if this vector is numeric, output the median as a character, otherwise the class of the vector.\n\n\n\n\n\n\n\nCaution\n\n\n\n\n\n\ncheck_median &lt;- function(vec){\n  if(is.numeric(vec)){\n    result &lt;- median(vec, na.rm = TRUE)\n  } else{\n    result &lt;- class(vec)\n  }\n  ## Convert to character, so our function always returns the correct type\n  result &lt;- as.character(result)\n  return(result)\n}\n\n## Check it:\ncheck_median(c(100, 1000))\n\n[1] \"550\"\n\ncheck_median(c(\"a\", \"b\"))\n\n[1] \"character\"\n\n\n\n\n\n\nUse it in the for-loop.\n\n\n\n\n\n\n\nCaution\n\n\n\n\n\n\nvec_median &lt;- c()\nfor(i in 1:ncol(iris)){\n  vec_median[i] &lt;- check_median(iris[, i])\n}\n\nvec_median\n\n[1] \"5.8\"    \"3\"      \"4.35\"   \"1.3\"    \"factor\""
  },
  {
    "objectID": "posts/r_sig/23_31_07_apply/index.html#exercise-3",
    "href": "posts/r_sig/23_31_07_apply/index.html#exercise-3",
    "title": "The apply family",
    "section": "Exercise 3",
    "text": "Exercise 3\nRewrite the for-loop from Exercise 1 with functions from the apply-family, so it returns the following objects. Define the function that gets applied on every input element externally, so we have cleaner code.\n\nA vector.\n\n\n\n\n\n\n\nCaution\n\n\n\n\n\n\nsapply(iris, check_median)\n\nSepal.Length  Sepal.Width Petal.Length  Petal.Width      Species \n       \"5.8\"          \"3\"       \"4.35\"        \"1.3\"     \"factor\" \n\n\nOr, even better:\n\nvapply(iris, check_median, character(1))\n\nSepal.Length  Sepal.Width Petal.Length  Petal.Width      Species \n       \"5.8\"          \"3\"       \"4.35\"        \"1.3\"     \"factor\" \n\n\nWow, that’s pretty nice, we condensed our function to half a line by defining the function somewhere else, and not using a for-loop!\n\n\n\n\nA list.\n\n\n\n\n\n\n\nCaution\n\n\n\n\n\n\nlapply(iris, check_median)\n\n$Sepal.Length\n[1] \"5.8\"\n\n$Sepal.Width\n[1] \"3\"\n\n$Petal.Length\n[1] \"4.35\"\n\n$Petal.Width\n[1] \"1.3\"\n\n$Species\n[1] \"factor\""
  },
  {
    "objectID": "docs/reproduce/renv.html",
    "href": "docs/reproduce/renv.html",
    "title": "The renv-Package",
    "section": "",
    "text": "Reproducibility\nProject repo for reproducibility research. Currently, we are working on making the BT21 reproducible by using the renv-Package in R.\n\n\nrenv\nThe renv-package is intended for simple project-local R dependency management. Here you’ll find a more thorough introduction.\n\n\nSetup\n\nCreate an RStudio Project in the working directory that should be made reproducible.\nIf another R-version should be used, switch to that version. On Windows, you can simply install multiple versions of R and switch between them in RStudio by going to Tools - Global Options - General. Maybe you will have to install renv for this version again.\nInitialise the project using renv::init(). This creates the basic infrastructure for the usage of renv.\n\n\nDependencies should be discovered automatically. It can take a while, if you’re doing this for the first time.\nIf you want to install specific package versions, you can use renv::intit(bare = TRUE).\n\nThis sets up the renv project without trying to find the used dependencies. Thus, you can install the specific versions manually afterwards.\n\nThe dependencies in the working directory can be obtained by renv::dependencies().\n\n\n\nIf you want specific package versions, you can use renv::install(packagename/@version-number). Local packages or packages from GitHub can be installed as well (see here).\nIn the end, packages should be installed in ./renv/library. A lockfile ./renv.lock is created, where the R version and the package versions are noted.\nNow you can work with the project. If you update dependencies, for example when you install and/or load new packages, you can save the state of the project library to the lockfile using renv::snapshot().\nIf you want to restore the state of the project library as noted in the lockfile, use renv::restore().\n\n\n\nProject usage\n\nFor maximal reproducibility, check the lockfile for the R-version before working with renv. If another R-version is documented in the lockfile, you can change the R-version before reproducing an analysis, see 2).\nAs the packages are directly installed into the project working directory, you should be able to simply work with the renv-project as saved by the last user without doing anything.\n\n\n\nNote on Package Versions\nMRAN can be used to get snapshots of R on any day back to 17.09.2014. Here, package versions on specific dates can be found, for example, when a script was finished on 06.05.22, the packages probably used can be obtained from here. Sometimes an error similar to this can occur:\nError: install of package 'tidyselect' failed [error code 1]\nIn this case it is possible to look up the package version on the respective date on MRAN and install this version manually. On 06.05.22, CRAN hosted Version 1.1.2 of tidyselect, so you install the version like so: renv::install(\"tidyselect@1.1.2\")."
  },
  {
    "objectID": "docs/R/ws1.html",
    "href": "docs/R/ws1.html",
    "title": "R Workshop Einführung",
    "section": "",
    "text": "R ist eine Programmiersprache für Datenmanipulation, statistische Datenanalyse und grafische Darstellung von Daten (Yanada, 2018).\nDatenmanipulation:\n\nImport und Export: Einlesen und Schreiben von SPSS-, Excel-, ASCII- oder trennzeichenbasierten Dateien\nKopieren, verschieben, löschen, packen und entpacken von Dateien und Verzeichnissen\nVariablen- und Fallselektion, Rekodieren/Aggregieren von Variablen\nUmstrukturieren von Datensätzen (long/wide)\nManipulation von Zeichenketten (Verknüpfen, extrahieren, ersetzen, z.B. auch mithilfe regulärer Ausdrücke: sehr mächtig, aber zuweilen kompliziert)\n\nstatistische Datenanalyse:\n\nlineare und nichtlineare Regression\nVarianzanalyse\nStrukturgleichungsmodelle\nMehrebenenanalyse\nMultiple Imputation\nItem-Response-Modelle\ndecision trees\nmixed models, u.v.m.\n\ngrafische Darstellung von Daten:\n\nBoxplots\nHistogramme\nHeat Maps"
  },
  {
    "objectID": "docs/R/ws1.html#einleitung",
    "href": "docs/R/ws1.html#einleitung",
    "title": "R Workshop Einführung",
    "section": "",
    "text": "R ist eine Programmiersprache für Datenmanipulation, statistische Datenanalyse und grafische Darstellung von Daten (Yanada, 2018).\nDatenmanipulation:\n\nImport und Export: Einlesen und Schreiben von SPSS-, Excel-, ASCII- oder trennzeichenbasierten Dateien\nKopieren, verschieben, löschen, packen und entpacken von Dateien und Verzeichnissen\nVariablen- und Fallselektion, Rekodieren/Aggregieren von Variablen\nUmstrukturieren von Datensätzen (long/wide)\nManipulation von Zeichenketten (Verknüpfen, extrahieren, ersetzen, z.B. auch mithilfe regulärer Ausdrücke: sehr mächtig, aber zuweilen kompliziert)\n\nstatistische Datenanalyse:\n\nlineare und nichtlineare Regression\nVarianzanalyse\nStrukturgleichungsmodelle\nMehrebenenanalyse\nMultiple Imputation\nItem-Response-Modelle\ndecision trees\nmixed models, u.v.m.\n\ngrafische Darstellung von Daten:\n\nBoxplots\nHistogramme\nHeat Maps"
  },
  {
    "objectID": "docs/R/ws1.html#r-als-taschenrechner",
    "href": "docs/R/ws1.html#r-als-taschenrechner",
    "title": "R Workshop Einführung",
    "section": "2. R als Taschenrechner",
    "text": "2. R als Taschenrechner\nIn der R Konsole kann man (mathematische) Funktionen eingeben und sie evaluieren lassen. Im einfachsten Fall funktioniert das wie ein Taschenrechner.\n\n2+3\n\n[1] 5\n\n2*3\n\n[1] 6\n\n\nDas Dezimaltrennzeichen in R ist ein Punkt, kein Komma.\n\n5/4\n\n[1] 1.25\n\n\nExponentialschreibweise:\n\n2^3\n\n[1] 8\n\n\nObwohl es nicht so aussieht, werden bei diesen Operationen im Hintergrund Funktionen ausgeführt. So kann man sich beispielsweise die Wurzel aus 2 einfach in Exponentialschreibweise oder mithilfe der Wurzelfunktion ausgeben lassen:\n\n2^0.5\n\n[1] 1.414214\n\n\nWurzelfunktion:\n\nsqrt(2)\n\n[1] 1.414214\n\n\nAllgemein gilt auch in R: “Punktrechnung vor Strichrechnung”:\n\n2*3+1\n\n[1] 7\n\n2*(3+1)\n\n[1] 8"
  },
  {
    "objectID": "docs/R/ws1.html#grundlagen",
    "href": "docs/R/ws1.html#grundlagen",
    "title": "R Workshop Einführung",
    "section": "3. Grundlagen",
    "text": "3. Grundlagen\nR ist zugleich eine Sprache und eine Umgebung für statistische Datenbearbeitung. R ist objektbasiert. Alles in R ist ein Objekt: Zahlen, Vektoren, Matrizen, Funktionen. Das grundlegende Funktionsprinzip ist dabei: “Definiere ein Objekt und weise ihm einen Wert zu.” Im einfachsten Fall wird im folgenden Beispiel das Objekt b erzeugt und ihm der Wert 2 zugewiesen. Um sich den Wert von b anzeigen zu lassen, kann man b einfach in die Konsole tippen:\n\nb &lt;- 2\nb\n\n[1] 2\n\n\nb** ist nun intern gespeichert und kann ebenfalls für Zuweisungen benutzt werden. Hier wird ein neues Objekt d erzeugt und ihm als Wert die Quadratwurzel von b zugewiesen:\n\nd &lt;- sqrt(b)\n\nMöglich ist es auch, b wieder mit einem anderen Wert zu überschreiben:\n\nb &lt;- 100 * b\nb\n\n[1] 200\n\n\nMit dem Befehl class kann man sich die Klasse von b anzeigen lassen.\n\nclass(b)\n\n[1] \"numeric\"\n\n\nDie wichtigsten Klassen für skalare Objekt (also solche, die nur aus einem einzigen Element bestehen), sind\n\nnumeric: reelle Ziffer oder Zahlen\ncharacter: Zeichenkette\nlogical: logischer Wert, der nur zwei Zustände annehmen kann, TRUE oder FALSE\n\nIm folgenden verschiedene Beispiele für character- bzw. logische Zuweisungen, hier jeweils wiederum nur für die Länge 1. Zuweisungen der Klasse character erfolgen mit hochgestellten Anführungszeichen:\n\nd &lt;- \"hallo\"\nclass(d)\n\n[1] \"character\"\n\nlength(d)\n\n[1] 1\n\n\nWenn einem Objekt die Zahl 220 in hochgestellten Anführungszeichen zugewiesen wird, wird der Wert nicht als numerisch, sondern als character behandelt:\n\ne &lt;- \"220\"\nclass(e)\n\n[1] \"character\"\n\n\nWenn einem Objekt der Austruck TRUE in hochgestellten Anführungszeichen zugewiesen wird, wird der Wert nicht als logical, sondern als character behandelt:\n\nf &lt;- TRUE\nclass(f)\n\n[1] \"logical\"\n\ng &lt;- \"TRUE\"\nclass(g)\n\n[1] \"character\"\n\n\n\n3.1 Vektoren\nVektoren sind definiert als eine Reihe von Elementen derselben Klasse. Sie können unter anderem mit der Funktion c() erzeugt werden:\n\na &lt;- c(1,4,2,2,89)\nb &lt;- c(\"gut\", \"schlecht\")\nd &lt;- c(TRUE, TRUE, TRUE, FALSE, TRUE, TRUE)\n\nÄhnlich wie in den vorher aufgeführten Beispielen kann man sich mit verschiedenen Befehlen verschiedene Eigenschaften dieser Vektoren zeigen lassen, etwa ihre Länge (= die Anzahl ihrer Elemente) mit length(), oder ihre Klasse mit class(). Bestimmte Funktionen wiederum kann man sinnvoll nur für numerische Vektoren anweden (z.B. sum(), mean(), min(), max() etc. Andere wiederum sind nur für Vektoren der Klasse character sinnvoll, etwa nchar(), das einem die Anzahl der Zeichen einer Zeichenkette gibt. Ganz allgemein gilt: Funktionen, die man auf Skalare anwenden kann, kann man in der Regel auch auf Vektoren anwenden:\n\nskalar &lt;- 2\nsqrt(skalar)\n\n[1] 1.414214\n\nvektor &lt;- c(1,4,2,2,89)\nsqrt(vektor)\n\n[1] 1.000000 2.000000 1.414214 1.414214 9.433981\n\n\nDie Funktion sqrt gibt dabei genauso viele Elemente zurück, wie der Vektor besitzt, den man der Funktion übergeben hat. Das ist nicht bei allen Funktionen so; die mean-Funktion gibt (sinnvollerweise) immer nur ein Element zurück.\n\nskalar &lt;- 2\nmean(skalar)\n\n[1] 2\n\nvektor &lt;- c(1,4,2,2,89)\nmean(vektor)\n\n[1] 19.6\n\n\nWas passiert, wenn man Vektoren “unzulässig” definiert, also beispielsweise die Regel, dass alle Elemente dieselbe Klasse haben müssen, missachtet? Vektoren werden in die “kleinste gemeinsame Klasse” umgewandelt. Es gibt hier keine Warnmeldung, und manchmal führt das zu unerwünschten Nebenwirkungen. Zuerst betrachten wir einen Vektor, der aus Elementen der Klasse numeric, character und logical besteht:\n\nb &lt;- c(1,6,\"hallo\",TRUE,11,FALSE)\nb\n\n[1] \"1\"     \"6\"     \"hallo\" \"TRUE\"  \"11\"    \"FALSE\"\n\n\nDer gesamte Vektor wird als character definiert:\n\nclass(b)\n\n[1] \"character\"\n\n\nBesteht der Vektor nur aus Elementen der Klassen numeric und logical, wird der Vektor als numeric definiert:\n\nb &lt;- c(1,6,TRUE,11,FALSE)\nb\n\n[1]  1  6  1 11  0\n\nclass(b)\n\n[1] \"numeric\"\n\n\nAn diesen Bespielen erkennt man prototypisch, wie R sich bei “widersinnigen” Benutzereingaben verhält: Anstatt bei formal falschen oder unsinnigen Eingaben wie nchar(15) eine Fehlermeldung auszugeben, wird versucht zu “antizipieren”, was der Benutzer gemeint oder beabsichtigt haben könnte. Bei nchar(15) wird also zunächst der numerische Ausdruck in einen character-Ausdruck umgewandelt und anschließend die Anzahl der Zeichen dieses Ausdrucks ausgegeben. Intern wertet R statt nchar(15) folgenden Ausdruck aus: nchar(\"15\") bzw. nchar(as.character(15)). Ein solches oder ähnliches Verhalten wendet R in unzähligen Fällen an, und daraus ergeben sich zugleich Vor- und Nachteile: es erlaubt dem Anwender, syntaktisch “unsauberen” Code zu verwenden, ohne dass es zu Fehlermeldungen kommt. In der Regel erhält man das gewünschte Ergebnis. Außerdem kann man R-Syntaxen teils sehr sparsam und “schreibfaul” erstellen; nchar(15) ist ja viel kürzer als nchar(as.character(15)). Dass R diese Nachlässigkeiten erlaubt, hat aber auch Nachteile: die syntaktische Logik der R-Sprache ist dadurch weniger transparent, und falls es doch zu Fehlermeldungen kommt, sind diese erstmal weniger verständlich.\nAlternative Möglichkeiten, Vektoren zu erzeugen. Alle Zahlen von 1 bis 20:\n\na &lt;- 1:20\n\nErzeuge eine Zahlenreihe von -2 bis +2 in Intervallen von 0.2:\n\na &lt;- seq(-2,2,0.2) \n\nRepliziere die Ziffer 4 dreimal:\n\na &lt;- rep(4,3)\n\nRepliziere die Zahlenfolge von 1 bis 4 dreimal:\n\na &lt;- rep(1:4,3)\n\nRepliziere in der Zahlenfolge von 1 bis 4 jede einzelne Ziffer dreimal:\n\na &lt;- rep(1:4,each=3)\n\nRepliziere in der Zahlenfolge von 1 bis 4 jede einzelne Ziffer dreimal, und repliziere den egsamten Vektor zweimal:\n\na &lt;- rep(1:4,each=3, times = 2)\n\nRepliziere in der Zahlenfolge von 1 bis 4 die 1 einmal, die 2 zweimal, die 3 dreimal, etc.:\n\na &lt;- rep(1:4,1:4)\n\n\n\n3.2 Navigation in Vektoren (subsetting)\nMithilfe eckiger Klammern kann man sich einzelne Elemente eines Vektors anzeigen lassen oder auch verändern.\n\nb &lt;- sqrt(1:5)\n\nDer gesamte Vektor b besteht aus fünf Zahlen:\n\nb\n\n[1] 1.000000 1.414214 1.732051 2.000000 2.236068\n\n\nMit b[2] kann man sich nur das zweite Element des Vektors anzeigen lassen; mit b[2] &lt;- 1000 kann man das zweite Element durch die Zahl 1000 ersetzen:\n\nb[2] &lt;- 1000\nb\n\n[1]    1.000000 1000.000000    1.732051    2.000000    2.236068\n\n\nMit b[4:5] &lt;- c(400, 500) kann man das vierte und fünfte Element durch die Zahlen 400 und 500 ersetzen:\n\nb[4:5] &lt;- c(400, 500)\nb\n\n[1]    1.000000 1000.000000    1.732051  400.000000  500.000000\n\n\nHier ein weiteres Beispiel für ein syntaktisch “fehlerhaftes” Subsetting, das trotzdem funktioniert. Man würde erwarten, dass b[4:5] &lt;- 45 eine Fehlermeldung gibt: zwei Elemente in einem Vektor sollen durch eine Zahl ersetzt werden. Die “sauberere” Lösung wäre b[4:5] &lt;- c(45, 45). Dennoch funktionier auch b[4:5] &lt;- 45:\n\nb[4:5] &lt;- 45\nb\n\n[1]    1.000000 1000.000000    1.732051   45.000000   45.000000\n\n\nWeitere “unzulässige” Operationen haben wieder denselben Effekt wie oben beschrieben. Ersetze ich ein Element des numerischen Vektors durch ein character-Element, wird der gesamte Vektor ebenfalls nach character umgewandelt.\n\nb[1] &lt;- \"hallo\"\nclass(b)\n\n[1] \"character\"\n\nb\n\n[1] \"hallo\"            \"1000\"             \"1.73205080756888\" \"45\"              \n[5] \"45\"              \n\n\n\n\n3.3 Funktionsliste I: Deskriptive Statistiken für numerische Vektoren\nAlle Funktionen, die sich sinnvoll auf numerische Vektoren anwenden lassen, können hier in ihrer Vollständigkeit nicht aufgeführt werden. Im Folgenden sollen jedoch die gebräuchlichsten und am häufigsten verwendeten aufgelistet werden:\n\nsum(). Berechnet die Summe aller Elemente eines Vektors. Nicht definiert für nicht-numerische Vektoren.\nmean(). Arithmetischer Mittelwert aller Elemente eines Vektors. Nicht definiert für nicht-numerische Vektoren.\nsd(). Standardabweichung\nvar(). Varianz\nmin(). Minimum\nmax(). Maximum\nscale(). Funktion zum Zentrieren oder z-Standardisieren. Die Funktion besitzt zusätzliche Argumente, je nachdem ob standardisiert oder nur zentriert werden soll. Für die zusätzlichen Argumente sind Standardeinstellungen (defaults) definiert – also “Voreinstellungen” der Argumente, die benutzt werden, wenn der Anwender die Funktionsargumente selbst nicht explizit definiert. Ein Vektor a &lt;- rnorm(100, mean = 2, sd = 8) mit Mittelwert 2 und Standardabweichung 8 wird mit scale(a, center = TRUE, scale = FALSE) zentriert und mit scale(a, center = TRUE, scale = TRUE) standardisiert. (Bei scale(a, center = FALSE, scale = FALSE) passiert einfach gar nichts; der Vektor wird 1:1 so zurückgegeben, wie er war.)\ntable() gibt eine Häufigkeitsverteilung aller Werte eines Vektors. Das ist sowohl für numerische als auch für nicht-numerische Vektoren möglich und für letztere häufig sinnvoller.\nsort(). Elemente auf- oder absteigend sortieren. Geht auch für nicht-numerische Vektoren (bei character-Vektoren wird in diesem Fall sortiert, bei Faktoren nach Ordnung der factor levels). Auch sort() enthält zusätzliche Argumente mit Voreinstellungen, z.B. das Argument decreasing, das angibt, ob auf- oder absteigend sortiert werden soll. Der default ist hier decreasing = FALSE; es wird also standardmäßig aufsteigend sortiert.\norder() funktioniert ähnlich wie sort(), gibt aber anstelle des Vektor-Wertes die Position zurück. Am einfachsten lässt sich das mit einem character-Vektor veranschaulichen – hier erkennt man auch, dass verschiedene R-Funktionen zueinander häufig redundant sind; es gibt verschiedene syntaktische Möglichkeiten, ein und dasselbe Ergebnis zu erhalten. Das macht R zum einen recht flexibel, zum anderen nicht unbedingt übersichtlich.\n\n\nvek &lt;- c(\"oh\", \"je\", \"mi\", \"neh\")\nsort(vek)\n\n[1] \"je\"  \"mi\"  \"neh\" \"oh\" \n\norder(vek)\n\n[1] 2 3 4 1\n\nvek[order(vek)]\n\n[1] \"je\"  \"mi\"  \"neh\" \"oh\" \n\n\n\nrev() kehrt die Reihenfolge der Elemente eines Vektors um\nunique() zeigt die Elemente des Vektors und lässt alle mehrfach vorhandenen Werte aus.\nduplicated() gibt einen logischen Vektor zurück, der für jedes Element anzeigt, ob es einzigartig ist (FALSE) oder mindestens zweimal vorkommt (TRUE)\nwhich() gibt zurück, an welcher Stelle (oder welchen Stellen) eines Vektors sich ein bestimmtes Element befindet, z.B. which(x == 5), oder eine bestimmte Bedingung erfüllt ist which(x &gt; 5), oder which(x != 5)\n\nDas sind, wie gesagt, bei weitem nicht alle Funktionen für numerische Vektoren. Wenn man eine bestimmte Operation durchführen möchte und den R-Befehl nicht kennt, hilft es häufig, die gewünschte Operation bei Google mit dem Zusatz “R” oder “R CRAN” einzugeben, vorzugsweise in englisch, z.B. “R sort by more than one variable”.\n\n\n3.4 Funktionsliste II: Bearbeiten von character-Vektoren\nIm Anwendungsfall von Large-scale Assessments im Bildungsforschungsbereich kommen character-Vektoren bspw. in Variablen- oder Itemnamen vor. Weniger häufig begegnet man ihnen unter anderem auch in Freitextfeldern in Schülerfragebögen. R bietet zahlreiche Möglichkeiten zur Bearbeitung von character-Vektoren, die auch reguläre Ausdrücke einschließen. Hier sollen nur die wichtigsten anhand prominenter Anwendungsfälle genannt werden. Man könnte sich beispielsweise vorstellen, in einem großen Datensatz mit vielen Variablen bestimmte Spalten oder Variablen identifizieren beziehungsweise verändern zu wollen. Der beispielhaft verwendete Vektor mit Variablennamen sei der folgende:\n\nvarnamen &lt;- c(\"idstud\", \"idclass\", \"D10101a\", \"D10102a\", \"D10102b\", \"D10103a\", \"D10201a\", \"D10301\", \"sex\", \"M15511a\", \"M15612a\", \"M15712b\", \"M15712c\", \"M15712d\", \"hisced\", \"parid\")\n\nInsgesamt gibt es hier nur 14 Variablen – in großen Large-scale Datensätzen hat man es ja zuweilen mit 1000 variablen und mehr zu tun.\n\nDie Funktion grep()\ngrep() erlaubt, einen character-vektor nach einem bestimmten Muster zu durchsuchen. Zurückgegeben werden alle Positionen, an denen dieses Muster auftritt. Man kann sich das ein bisschen wie die Suchfunktion in Word vorstellen. grep() hat verschiedene Argumente – pattern gibt das Muster an, was gesucht werden soll, x gibt den character-Vektor an, in dem gesucht werden soll, und value gibt als logisches Argument an, ob der Wert selbst oder seine Position zurückgegeben werden soll. Die Flexibilität von grep() rührt unter anderem auch daher, dass man als Suchmuster (pattern) auch reguläre Ausdrücke verwenden kann.\n\ngrep(pattern=\"id\", x=varnamen) findet die Positionen der Variablennamen, die ein “id” im Variablennamen haben.\ngrep(pattern=\"id\", x=varnamen, value=TRUE) zeigt die Variablennamen an, die ein “id” im Variablennamen haben.\ngrep(pattern=\"^id\", x=varnamen, value=TRUE) zeigt die Variablennamen an, die mit einem “id” im Variablennamen beginnen. (Der “Haken” vor dem “id” besagt, dass der Variablenname mit “id” beginnen muss)\nWenn ich id-Variablen finden will, mit aber nicht sicher bin, ob die in dem Datensatz groß oder klein geschrieben sind, ich aber im Zweifel beide haben will, kann man die “Oder”-verknüpfung nehmen (genaueres im Abschnitt “Logische Operatoren”): grep(pattern=\"ID|id\", x=varnamen, value=TRUE)\nAuch den letzten Befehl kann man “einengen”, dass nur die Variablennamen gesucht werden sollen, die mit einem groß oder kleingeschriebenen “ID” beginnen: grep(pattern=\"^ID|^id\", x=varnamen, value=TRUE)\nDas ist auch sinnvoll, wenn ich beispielsweise alle Variablennamen der Deutsch-Items identifizieren will und weiß, Deutsch-Items beginnen mit einem groß geschriebenen “D”: grep(pattern=\"^D\", x=varnamen, value=TRUE)\nGenauso kann man auch nur die Variablennamen suchen, die mit einem klein geschriebenen “a” aufhören: grep(pattern=\"a$\", x=varnamen, value=TRUE). Das “$”-Zeichen gibt an, dass nach dem Zeichen “a” der Variablenname zuende sein muss.\nMöglich (aber etwas komplizierter) sind auch Verknüpfungen der Art: Finde alle Variablennamen, die mit einem “D” beginnen und einem “a” aufhören. Hier handelt es sich um eine logische Verknüpfung zweier Bedingungen – genauer wird darauf im folgenden Abschnitt “Logische Operatoren” eingegangen. In R kann man das auf verschiedenen Wegen realisieren; eine Möglichkeit soll hier kurz demonstriert werden:\n\n\nbeginnt_mit_D &lt;- grep(pattern=\"^D\", x=varnamen, value=TRUE)\nendet_mit_a   &lt;- grep(pattern=\"a$\", x=varnamen, value=TRUE)\nbeides        &lt;- intersect(beginnt_mit_D, endet_mit_a)\nbeides\n\n[1] \"D10101a\" \"D10102a\" \"D10103a\" \"D10201a\"\n\n\n\n\nDie Funktionen gsub(), substr(), substring(), nchar() und strsplit()\n\ngsub() erlaubt es, Teile eines character-Vektors zu ersetzen. Sollen bspw. in der Variablenliste alle Namen, die mit “D101” beginnen, durch “D201” ersetzt werden, geht das mit gsub(pattern = \"D101\", replacement = \"D201\", x = varnamen). Hier ist es wichtig, die Stelligkeit zu beachten; gsub(pattern = \"D1\", replacement = \"D2\", x = varnamen) würde auch z.B. “D102” durch “D202” ersetzen. Möglich, aber nicht notwendig ist hier auch, die Ersetzung nur durchzuführen, wenn “D101” am Anfang des strings steht: gsub(pattern = \"^D101\", replacement = \"D201\", x = varnamen).\nsubstr() erlaubt es, bestimmte Teile eines character-Vektors “auszuschneiden”: wenn man bspw. nur die ersten 4 Zeichen ausschneiden will, geht das mit substr(x = varnamen, start = 1, stop = 4). Zeichenketten mit weniger als 4 Zeichen (hier etwa der Variablenname “sex”) werden dabei so beibehalten, wie sie waren.\nMöchte man von dem character-Vektor nur am Anfang bspw. das erste Zeichen entfernen und alle anderen beibehalten (egal, wie viele es sind), bietet sich die Funktion substring() an: substring(text = varnamen, first = 2)\nnchar() einem für jedes Element die Anzahl von Zeichen (Buchstaben und Ziffern): nchar(varnamen)\nstrsplit() teilt einen character-Vektor an einem definierten Zeichen\n\n\n\nDie Funktion paste()\nDie Funktion erlaubt es, character-Vektoren aus einzelnen Elementen “zusammenzubauen”. Soll beispielsweise an den Variablennamens-Vektor varnamen das Jahr der Erhebung mit angefügt werden, geht das mit folgendem Ausdruck: paste(varnamen, \"2012\", sep=\"_\"). An jeden Variablennamen wurde nun die Jahreszahl 2012 angefügt. Der Argument sep gibt dabei das Zeichen an, das als “Trenner” zweischen dem ursprünglichen Ausdruck und dem “Suffix” 2012 verwendet werden soll. paste() ist eine recht mächtige Funktion, so kann man bspw. auch an jeden Variablennamen die laufende Nummer anhängen, die er im character-Vektor einnimmt: paste(varnamen, 1:length(varnamen), sep=\"_\"). Es ist auch möglich, alle Elemente des Vektor zu einem einzigen großen String zusammenzubinden: paste(varnamen, collapse=\"_\"). Die wichtige, aber häufig Verwirrung stiftende Unterscheidung liegt hierbei zwischen den Separationsargumenten sep und collapse. sep definiert das Trennzeichen für die einzelnen Terme; collapse (ggf.) das Trennzeichen, mit dem die Ergebnisse zusammengefügt werden (sofern sie zusammengefügt werden sollen). Die Hilfeseite der paste-Funktion liefert einige anschauliche Beispiele, die die Unterscheidung zwischen beiden verdeutlichen.\n\n\nFunktionen aus eatTools\nIm Laufe der Datenaufbereitungsprozeduren am IQB wurden die obenstehenden Funktionen teils erweitert. Ohne Anspruch auf Vollständigkeit sollen weitere Möglichkeiten der Zeichenkettenmanipulation kurz genannt werden:\n\neatTools::crop() entfernt führende oder abschließende Leerzeichen (bzw. ein frei definiertes Zeichen) aus einem character-Vektor. Das ist bspw. dann sinnvoll, wenn in inakkurat aufbereiteten Datensätzen z.B. anstatt einer 1 der Wert 1 (also mit einem unbeabsichtrigten leerzeichen eingetragen wurde. Hier werden (nur der Anschaulichkeit zuliebe) alle führenden und abschließenden “D”s aus den Variablennamen entfernt: eatTools::crop(varnamen, char = \"D\")\neatTools::removeNumeric() entfernt alle Ziffern aus einem character-Vektor: eatTools::removeNumeric(varnamen)\neatTools::removeNonNumeric() entfernt alle Buchstaben aus einem character-Vektor und lässt nur die Ziffern übrig. Manche Elemente von varnamen sind hinterher leer. eatTools::removeNonNumeric(varnamen)\neatTools::removePattern() entfernt ein bestimmtes Muster aus einem character-Vektor: eatTools::removePattern(string = varnamen, pattern = \"id\")"
  },
  {
    "objectID": "docs/R/ws1.html#logische-operatoren",
    "href": "docs/R/ws1.html#logische-operatoren",
    "title": "R Workshop Einführung",
    "section": "4. Logische Operatoren",
    "text": "4. Logische Operatoren\nAllgemeines zu logischen Operatoren kann man auf der gleichnamigen Wikipediaseite finden: https://de.wikipedia.org/wiki/Logischer_Operator\nFür sämtliche Operatoren gibt es eine Entsprechung in R. Die Syntax ist dabei (weitgehend) äquivalent zu den angegeben Beispielen für C, C++, Java und PHP auf der Wikipediaseite. Der Wahrheitswert, der in R zurückgegeben wird, hat die Klasse logical und kann 2 Werte annehmen: TRUE oder FALSE. Der Wahrheitswert kann wiederum einem Objekt zugewiesen werden:\n\nistWahr &lt;- 4 == 5 \nclass(istWahr)\n\n[1] \"logical\"\n\nistWahr\n\n[1] FALSE\n\n\n\nLogische Operatoren ohne Verknüpfung\n\nist größer als: 4 &gt; 3\nist kleiner als: 4 &lt; 3\nist größer oder gleich: 4 &gt;= 3\nist kleiner oder gleich: 4 &lt;= 3\nist gleich: 4 == 3\nist ungleich: 4 != 3\n\n\n\nLogische Operatoren mit Verknüpfungen\n\nBedingung a UND Bedingung b sind erfüllt: 4 &gt; 3 & is.numeric(5)\nBedingung a ODER Bedingung b ist erfüllt: 4 &gt; 3 | is.numeric(5)\nENTWEDER Bedingung a ODER Bedingung b ist erfüllt: xor(4 &gt; 3, is.numeric(5)). Hier wird FALSE zurückgegeben, da beide Bedingungen erfüllt sind, und eben nicht nur entweder a oder b.\nBedingung b ist nicht erfüllt: !is.numeric(\"a\"). Hier wird TRUE zurückgegeben, denn es ist ja wahr, dass “a” nicht numerisch ist.\n\n\n\nArbeiten mit vektorwertigen logischen Verknüpfungen\nIn den oberen Beispielen wurden logische Abfragen immer nur für ein Objekt der Länge 1 durchgeführt. Man kann diese Funktionen aber auch auf Vektoren anwenden. Dazu folgendes hypothetisches Beispiel: ein großer Datensatz mit vielen Variablen soll in Mplus ausgewertet werden. In Mplus dürfen Variablennamen jedoch nur maximal 6 Zeichen haben. Gibt es also in dem Variablennamens-Vektor varnamen Variablennamen mit unerlaubter Länge? Um das zu prüfen, geht man in mehreren Schritten vor:\n\nZeige für jedes Element im Variablennamens-Vektor die Anzahl von Buchstaben an.\n\n\nanzahl &lt;- nchar(varnamen)\n\n\nPrüfe, für welche Variablennamen die zulässige Zeichenanzahl überschritten ist. Dazu wird ein logischer Vektor erzeugt, der den Wert TRUE annimmt, wenn die Zeichenanzahl maximal 6 beträgt, andernfalls FALSE.\n\n\nerlaubt &lt;- anzahl &lt;= 6\nerlaubt\n\n [1]  TRUE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE  TRUE FALSE FALSE FALSE\n[13] FALSE FALSE  TRUE  TRUE\n\n\n\nNun wird geprüft, ob diese Bedingung für alle Variablennamen erfüllt ist. Dazu können die Funktionen all() oder any() benutzt werden. all() fragt: Haben alle Elemente des Vektors erlaubt den Wahrheitswert TRUE? any() fragt: Gibt es irgendein Element in dem Vektors erlaubt, das den Wahrheitswert FALSE hat?\n\n\nall(erlaubt)\n\n[1] FALSE\n\nany(erlaubt == FALSE)\n\n[1] TRUE\n\n\n\nJa, einige Variablennamen haben eine größere Zeichenanzahl als 6. Man kann die Variablennamen auf die ersten 6 Zeichen reduzieren:\n\n\nvarnamen_neu &lt;- substr(varnamen, 1, 6)\n\n\nVariablennamen müssen jedoch stets einzigartig (unique) sein. Ist das jetzt noch der Fall? Dazu verwendet man die oben beschriebene Funktion duplicated() in Verbindung mit any:\n\n\nany(duplicated(varnamen_neu))\n\n[1] TRUE\n\n\nDer Wahrheitswert ist TRUE, es gibt also mindestens zwei Variablennamen, die jetzt identisch sind. An dieser Stelle könnte es passieren, dass man erstmal nicht weiter weiß. Eine Möglichkeit wäre, zu googlen: “r make unique”. So findet man eine Funktion namens make.unique, die es erlaubt, duplizierte Werte in character-Vektoren zu ersetzen, so dass sie einzigartig werden. Unglücklicherweise werden dadurch die Variablennamen wieder länger, als sie sein dürfen:\n\nvarnamen_neu2 &lt;- make.unique(varnamen_neu)\nany(nchar(varnamen_neu2)&gt;6)\n\n[1] TRUE\n\n\nTatsächlich gibt es für dieses Problem also keine einfache, “triviale” Lösung. Man könnte entweder vollständig willkürliche Namen vergeben, die dann aber keine Rückschlüsse auf die ursprüngliche Variablenbedeutung mehr zulassen, oder man experimentiert, beruhend auf folgenden Überlegungen: make.unique fügt an nicht-unique Variablennamen einen Punkt und eine laufende Nummer an, also zwei zusätzliche Zeichen. Also dürfte man nur die ersten 4 Zeichen der Variablennamen beibehalten:\n\nvarnamen_neu3 &lt;- make.unique(substr(varnamen, 1, 4))\nany(nchar(varnamen_neu3)&gt;6)\n\n[1] FALSE\n\nany(duplicated(varnamen_neu3))\n\n[1] FALSE\n\nvarnamen_neu3\n\n [1] \"idst\"   \"idcl\"   \"D101\"   \"D101.1\" \"D101.2\" \"D101.3\" \"D102\"   \"D103\"  \n [9] \"sex\"    \"M155\"   \"M156\"   \"M157\"   \"M157.1\" \"M157.2\" \"hisc\"   \"pari\"  \n\n\nHundertprotentig schön ist auch diese Variante nicht, weil nun auch von bereits einzigartigen Variablennamen nur die ersten vier Zeichen übrig behalten worden sind, obwohl es hier ja hätten sechs sein dürfen. Sofern eine solche Operation im Arbeitsalltag also häufiger gebraucht wird, wäre es günstig, sich dafür eine eigene Funktion zu schreiben, um diese Prozesse weniger umständlich zu gestalten. Dazu aber an anderer Stelle mehr."
  },
  {
    "objectID": "docs/R/ws1.html#fehlende-werte-missing-values",
    "href": "docs/R/ws1.html#fehlende-werte-missing-values",
    "title": "R Workshop Einführung",
    "section": "5. Fehlende Werte (missing values)",
    "text": "5. Fehlende Werte (missing values)\nFehlende Werte werden in R mit NA (not available) gekennzeichnet. Im Folgenden geht es nicht darum, wie in statistischen Analysen mit fehlenden Werten umgegangen werden kann, sondern wie man sie in R technisch behandelt. Dazu soll beispielhaft ein numerischer Vektor betrachtet werden, der fehlende Werte enthält:\n\nnumvek &lt;- rnorm(20, 0, 1)\nnumvek[c(3,6,9,19)] &lt;- NA\n\n\nDie häufigsten im Zusammenhang mit fehlenden Werten gebräuchlichen Funktionen sind:\n\nis.na() gibt einen Vektor der Klasse logical zurück, dessen Wert TRUE ist, wenn es sich um einen fehlenden Wert handelt: is.na(numvek). Wenn man lediglich wissen, ob es überhaupt irgendwelche fehlenden Werte gibt, kann man das mit any() verbinden: any(is.na(numvek)). Wenn man wissen will, an welcher Stelle die fehlenden Werte stehen, geht which(is.na(numvek))\nAchtung! Anders als man vielleicht vermuten würde, funktioniert which(numvek == NA) nicht!\nWenn ich nur die beobachteten Werte aus numvek extrahieren möchte, also alles ausschließen, was NA ist, geht das mit na.omit(numvek). Dieser Vektor ist mit nur noch 16 Elementen folglich kürzer als der ursprüngliche mit 20 Elementen: length(na.omit(numvek))\nMöchte man sich beispielsweise den Mittelwert eines Vektors anzeigen lassen, der fehlende Werte enthält, ist das Ergebnis ebenfalls NA: mean(numvek). Meist will man jedoch einfach das arithmetisches Mittel aller beobachteten Werte. Dazu könnte man einfach den Mittelwert unter Ausschluss der fehlenden Werte bestimmen: mean(na.omit(numvek)). Das ist dasselbe, wie wenn man in der Funktion mean() mit einem zusätzlichen Argument definiert, dass fehlende Werte vor der Berechnung ausgeschlossen werden sollen: mean(numvek, na.rm = TRUE). Man sieht wieder, dass verschiedene syntaktische Umsetzungen zu dem gewünschten Ergebnis führen können. Das logische Argument na.rm ist für viele Funktionen definiert, so etwa var(), sd(), lm(), glm(), etc.\n\n\n\nFehlende Werte in character-Vektoren\nHier gilt im Grunde dasselbe wie für numerische Vektoren. Auf ein paar Fallstricke soll hingewiesen werden:\n\ncharvek &lt;- c(\"France\", \"Belgium\", \"Poland\", NA, \"Denmark\", \"NA\", \"Austria\", \"\")\nwhich(is.na(charvek))\n\n[1] 4\n\n\nAuch in character-Vektoren müssen fehlende Werte ohne hochgestellte Anführungszeichen eingetragen werden; der sechste Wert \"NA\" wird nicht als fehlender Wert verstanden. Ebensowenig der achte Wert, der einfach ein leerer String ist. Letzteres ist insofern relevant, dass, wenn man etwa csv-Dateien mit R einliest, leere Zellen manchmal als leere Strings eingelesen werden, obwohl man sie eigentlich wie fehlende Werte behandelt wissen will. Um das \"NA\" und den leeren String in einen wirklichen fehlenden Wert umzuwandeln, kann beispielsweise die recode()-Funktion aus dem Paket car verwendet werden:\n\ncharvek_neu &lt;- car::recode(charvek, \"'NA'=NA; ''=NA\")\ncharvek_neu\n\n[1] \"France\"  \"Belgium\" \"Poland\"  NA        \"Denmark\" NA        \"Austria\"\n[8] NA"
  },
  {
    "objectID": "docs/R/ws1.html#gut-zu-wissen",
    "href": "docs/R/ws1.html#gut-zu-wissen",
    "title": "R Workshop Einführung",
    "section": "6. Gut zu wissen",
    "text": "6. Gut zu wissen\nDen Überblick über die vorhandenen Funktionen und Pakete zu behalten, ist nahezu unmöglich; allein auf CRAN gibt es tausende von R-Paketen. Aus unserer subjektiven Sicht sollen daher die wichtigsten Funktionen, die sich im Laufe des IQB-Lebens als unverzichtbar herausgestellt haben, hier kurz ohne Anspruch auf Vollständigkeit aufgelistet werden. Wo nötig, werden Links für weiterführende Literatur angegeben:"
  },
  {
    "objectID": "docs/eatPackages/index.html",
    "href": "docs/eatPackages/index.html",
    "title": "Info on eat Packages",
    "section": "",
    "text": "see table down below and click on the links for more information on a package."
  },
  {
    "objectID": "docs/eatPackages/index.html#internal-iqb-r-packages-from-the-eat-family",
    "href": "docs/eatPackages/index.html#internal-iqb-r-packages-from-the-eat-family",
    "title": "Info on eat Packages",
    "section": "internal IQB R packages from the ‘eat’-family",
    "text": "internal IQB R packages from the ‘eat’-family\nIn order to standardise and simplify the evaluation of the VERA pilot studies and the IQB educational trend, a number of R packages with the prefix eat (“educational assessment tools”) are continuously (further) developed. Currently, the following packages are maintained at the IQB:\n\n\n\n\n\npackage name\nbrief description\ncontact\n\n\n\n\neatPrep\nPreparation of data sets.\nKaroline Sachse\n\n\neatModel\nInterface for ConQuest software.\nSebastian Weirich\n\n\neatRep\ncalculates characteristics for data with clustered multi-level structures with imputed data.\nSebastian Weirich, Benjamin Becker\n\n\neatGADS\nImport and data preparation of SPSS data sets in R.\nBenjamin Becker\n\n\neatTools\nVarious help functions that are also required by the packages ‘eatPrep’, ‘eatModel’, ‘eatGADS’ and ‘eatRep’, among others.\nSebastian Weirich, Benjamin Becker, Karoline Sachse\n\n\neatAnalysis\nVarious useful help functions, such as saving Excel files, saving analysis results from lm4 and simulating IRT responses.\nBenjamin Becker, Sebastian Weirich, Karoline Sachse\n\n\neatATA\nAutomated block occupation/automated test booklet creation.\nBenjamin Becker\n\n\neatFDZ\nAutomated anonymisation of data sets, matching of pdf documents (e.g. scale manuals) and data sets.\nBenjamin Becker\n\n\neatCodebook\nAutomated creation of scale manuals.\nBenjamin Becker\n\n\neatRecode\nCreate and apply recoding databases.\nBenjamin Becker, Nicklas Hafiz\n\n\neatPlot\nCreating plots from the eatRep output (main use: Bilduntstrend).\nNicklas Hafiz, Philipp Franikowski"
  },
  {
    "objectID": "docs/eatPackages/index.html#installing-r-packages",
    "href": "docs/eatPackages/index.html#installing-r-packages",
    "title": "Info on eat Packages",
    "section": "Installing R packages",
    "text": "Installing R packages\nDetailed instructions for installing the R packages can be found here: installing R packages"
  },
  {
    "objectID": "docs/eatPackages/index.html#compatibility",
    "href": "docs/eatPackages/index.html#compatibility",
    "title": "Info on eat Packages",
    "section": "Compatibility",
    "text": "Compatibility\nMost packages of the “eat” family are not executable in isolation, which means that a package is usually dependent on another package in order to be executable. This means:\n\n“eatTools” is a package with help functions required by other packages. “eatTools” does not depend on other “eat” packages.\neatPrep” requires “eatTools”.\neatRep” needs “eatTools” and “eatGADS”.\neatModel” requires “eatTools” and “eatRep” (and thus also “eatGADS”). The package optionally accesses the computer programme Conquest or the R package “TAM” for parameter estimation. For Conquest, the command line executable is sufficient, e.g. “console_Feb2007.exe”; “TAM” is installed when the package is loaded. “TAM” and Conquest are based on the same statistical measurement model, and overlap considerably in their range of functions.\n“eatGADS” requires “eatTools” and “eatDB”.\n\nThe interdependence also extends to different versions of the packages. For example, old versions of “eatRep” are not always compatible with new versions of “eatTools” (and vice versa). The current package versions (see table above) should be compatible with each other. Usually (but not always) version conflicts are indicated by an error message. It is recommended to always have the latest package versions installed.\nSince individual functions have also changed substantially in the course of the package development, it may no longer be possible to replicate past analyses with new package versions and the identical script (e.g. from the Ländervergleich 2011). In this case, the old script would either have to be adapted or the package versions used at that time would have to be restored."
  },
  {
    "objectID": "docs/eatPackages/eatPrep.html",
    "href": "docs/eatPackages/eatPrep.html",
    "title": "eatPrep",
    "section": "",
    "text": "Info\n\n\n\n\n\ncontact\nlatest version\nsource\n\n\n\n\nKaroline Sachse\nDESCRIPTION on github\ngithub page, internal\n\n\n\n\n\n\nDescription\nPreparation of data sets (reading, plausibility checks, merging of data sets, handling missings, recoding, aggregating, scoring and writing of labelled SPSS data sets) using item and test design information stored in the IQB database. This is extracted from the database using the ZKDaemon (see below) and written into a standardised xlsx format. This xlsx format is used by ‘eatPrep’ to transfer the information from the database to R.\n\n\n\n\n\nDocumentation\n\n\n\n\ninternal"
  },
  {
    "objectID": "docs/eatPackages/eatRep.html",
    "href": "docs/eatPackages/eatRep.html",
    "title": "eatRep",
    "section": "",
    "text": "Info\n\n\n\n\n\ncontact\nlatest version\nsource\n\n\n\n\nSebastian Weirich, Benjamin Becker\nCRAN page\nCRAN page\n\n\n\n\n\n\nDescription\nCalculates means, standard deviations, variances, frequency tables, percentiles and linear (logistic) regressions, as well as trends for all these analyses in clustered multilevel structures with imputed data. The package implements part of the functionality of the WesVar computer software in R and is mainly relevant for the IQB Bildungstrend studies.\n\n\n\n\n\nDocumentation\n\n\n\n\ninternal\n\n\ninternal\n\n\nReplication Analysis with eatRep\n\n\ninternal"
  },
  {
    "objectID": "docs/eatPackages/eatFDZ.html",
    "href": "docs/eatPackages/eatFDZ.html",
    "title": "eatFDZ",
    "section": "",
    "text": "Info\n\n\n\n\n\ncontact\nlatest version\nsource\n\n\n\n\nBenjamin Becker\nDESCRIPTION on github\ngithub page\n\n\n\n\n\n\nDescription\nAutomated anonymisation of data sets; comparison of pdf documents (e.g. scale manuals) and data sets.\n\n\n\n\n\nDocumentation"
  },
  {
    "objectID": "docs/eatPackages/eatTools.html",
    "href": "docs/eatPackages/eatTools.html",
    "title": "eatTools",
    "section": "",
    "text": "Info\n\n\n\n\n\ncontact\nlatest version\nsource\n\n\n\n\nSebastian Weirich, Benjamin Becker, Karoline Sachse\nCRAN page\nCRAN page\n\n\n\n\n\n\nDescription\nVarious help functions that are also required by the packages ‘eatPrep’, ‘eatModel’, ‘eatGADS’ and ‘eatRep’, among others.\n\n\n\n\n\nDocumentation\n\n\n\n\nReference manual"
  },
  {
    "objectID": "docs/eatPackages/eatPlot.html",
    "href": "docs/eatPackages/eatPlot.html",
    "title": "eatPlot",
    "section": "",
    "text": "Info\n\n\n\n\n\ncontact\nlatest version\nsource\n\n\n\n\nNicklas Hafiz, Philipp Franikowski\nDESCRIPTION on github\ngithub page\n\n\n\n\n\n\nDescription\nCreating plots from the eatRep output (main use: Bilduntstrend).\nDokumentation:\n\n\n\n\n\nDocumentation\n\n\n\n\nInfo page with several vignettes"
  },
  {
    "objectID": "docs/eatPackages/eatRecode.html",
    "href": "docs/eatPackages/eatRecode.html",
    "title": "eatRecode",
    "section": "",
    "text": "Info\n\n\n\n\n\ncontact\nlatest version\nsource\n\n\n\n\nBenjamin Becker, Nicklas Hafiz\nDESCRIPTION on github\ngithub page\n\n\n\n\n\n\nDescription\nCreate and apply recoding databases.\n\n\n\n\n\nDocumentation"
  },
  {
    "objectID": "docs/eatPackages/eatAnalysis.html",
    "href": "docs/eatPackages/eatAnalysis.html",
    "title": "eatAnalysis",
    "section": "",
    "text": "Info\n\n\n\n\n\ncontact\nlatest version\nsource\n\n\n\n\nBenjamin Becker, Sebastian Weirich, Karoline Sachse\nDESCRIPTION on github\ngithub page\n\n\n\n\n\n\nDescription\nVarious useful help functions, such as saving Excel files, saving analysis results from lm4 and simulating IRT responses.\n\n\n\n\n\nDocumentation\n\n\n\n\n-"
  },
  {
    "objectID": "docs/eatPackages/eatModel.html",
    "href": "docs/eatPackages/eatModel.html",
    "title": "eatModel",
    "section": "",
    "text": "Info\n\n\n\n\n\ncontact\nlatest version\nsource\n\n\n\n\nSebastian Weirich\nDESCRIPTION on github\ngithub page, intern\n\n\n\n\n\n\nDescription\nServes as an interface for the ConQuest software. The required control files (script, labels, data set in ‘fixed width’ format) are automatically generated and ConQuest is called via the command line. The resulting files (showfile, WLEs, PVs, etc.) can be imported back into R and edited further. Newer versions of ‘eatModel’ also allow the integration of the R package ‘tam’ and parallelisation.\n\n\n\n\n\nDocumentation\n\n\n\n\ninternal"
  },
  {
    "objectID": "docs/eatPackages/eatATA.html",
    "href": "docs/eatPackages/eatATA.html",
    "title": "eatATA",
    "section": "",
    "text": "Info\n\n\n\n\n\ncontact\nlatest version\nsource\n\n\n\n\nBenjamin Becker\nCRAN page\nCRAN page\n\n\n\n\n\n\nDescription\nAutomated block occupation/automated test booklet creation.\n\n\n\n\n\nDocumentation\n\n\n\n\ntypical use of ‘eat ATA’: a Minimal Example\n\n\n‘eatATA’ Functionality\n\n\na Pilot Study Example\n\n\nReference manual"
  },
  {
    "objectID": "docs/eatPackages/eatGADS.html",
    "href": "docs/eatPackages/eatGADS.html",
    "title": "eatGADS",
    "section": "",
    "text": "Info\n\n\n\n\n\ncontact\nlatest version\nsource\n\n\n\n\nBenjamin Becker\nCRAN page\nCRAN page\n\n\n\n\n\n\nDescription\nAllows import and data preparation of SPSS data sets in R. Generates the General Analysis Data Set (GADS) for IQB Bildungstrend studies as a SQLite3 database. Parts of the data set can then be loaded into R using the package. It also allows the export of SPSS files to and from R.\n\n\n\n\n\nDocumentation\n\n\n\n\nInfo page with several vignettes"
  },
  {
    "objectID": "docs/eatPackages/eatCodebook.html",
    "href": "docs/eatPackages/eatCodebook.html",
    "title": "eatCodebook",
    "section": "",
    "text": "Info\n\n\n\n\n\ncontact\nlatest version\nsource\n\n\n\n\nBenjamin Becker\nDESCRIPTION on github\ngithub page\n\n\n\n\n\n\nDescription\nAutomated creation of scale manuals.\n\n\n\n\n\nDocumentation\n\n\n\n\nInfo page with several vignettes"
  },
  {
    "objectID": "docs/R/index.html",
    "href": "docs/R/index.html",
    "title": "Material for learning R",
    "section": "",
    "text": "R Introduction\nAn introduction to R with hands on examples and exercises can be found in Introduction to R."
  },
  {
    "objectID": "docs/quarto/index.html",
    "href": "docs/quarto/index.html",
    "title": "Quarto",
    "section": "",
    "text": "Quarto websites\nCreating a website with Quarto.\nA nice hands on tutorial on adding blog posts to an existing Quarto website can be found here, along with some additional tips on citations, footnotes etc."
  },
  {
    "objectID": "posts/newsletter/23_08_09/index.html",
    "href": "posts/newsletter/23_08_09/index.html",
    "title": "09-08-2023",
    "section": "",
    "text": "eatGADS\nDie Funktion insertVariable() wurde in relocateVariable() umbenannt. Die Funktion erlaubt die Einsortierung einer Variable innerhalb eines GADSdat-Ojekts, nun auch ganz an den Anfang eines Datensatzes.\nEine neue Funktion, recodeNA2missing(), erlaubt es NAs (in SPSS auch Sysmis genannt) automatisch in spezifische Missing Codes umzuwandeln (z.B. -99 = \"Missing By Design\").\nDie Funktion emptyTheseVariables() erlaubt es nun, mehrere Variablen gleichzeitig zu leeren (= auf NA zu setzen), was z.B. aus Datenschutzgründen relevant sein kann.\nBesonders hervoheben möchten wir an dieser Stelle noch die Funktion fixEncoding(), die es erlaubt, automatisch Umlaute und Sonderzeichen aus Variablennamen, Variablen- und Wertelabeln, sowie Variablen an sich zu entfernen (z.B. “ü” wird zu “ue”).\nDie Dokumentation des Pakets ist nun übrigens leicht einsehbar hier zu finden.\nAlle Änderungen finden sich wie immer erst einmal in der Github-Version des Pakets."
  },
  {
    "objectID": "posts/r_sig/23_03_20_forloops/index.html",
    "href": "posts/r_sig/23_03_20_forloops/index.html",
    "title": "for-loops",
    "section": "",
    "text": "1"
  },
  {
    "objectID": "posts/r_sig/23_03_20_forloops/index.html#for-loops",
    "href": "posts/r_sig/23_03_20_forloops/index.html#for-loops",
    "title": "for-loops",
    "section": "For-loops",
    "text": "For-loops\nIn this session we talked about for-loops. Take a look here for the corresponding chapter in a workshop I’ve designed."
  },
  {
    "objectID": "posts/r_sig/23_03_20_forloops/index.html#footnotes",
    "href": "posts/r_sig/23_03_20_forloops/index.html#footnotes",
    "title": "for-loops",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nImage by Tine Ivanic on Unsplash.↩︎"
  },
  {
    "objectID": "posts_r_sig.html",
    "href": "posts_r_sig.html",
    "title": "R-SIG",
    "section": "",
    "text": "Order By\n       Default\n         \n          Date - Oldest\n        \n         \n          Date - Newest\n        \n         \n          Title\n        \n         \n          Author\n        \n     \n  \n    \n      \n      \n    \n\n\n\n\n\n\n\n\nDate\n\n\nTitle\n\n\nAuthor\n\n\nReading Time\n\n\n\n\n\n\n\n\n\nJul 7, 2025\n\n\nThe apply family\n\n\nNicklas Hafiz\n\n\n4 min\n\n\n\n\n\n\n\nMar 20, 2023\n\n\nfor-loops\n\n\nNicklas Hafiz\n\n\n1 min\n\n\n\n\n\n\nNo matching items"
  }
]