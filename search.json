[
  {
    "objectID": "docs/reproduce/renv.html",
    "href": "docs/reproduce/renv.html",
    "title": "The renv-Package",
    "section": "",
    "text": "Reproducibility\nProject repo for reproducibility research. Currently, we are working on making the BT21 reproducible by using the renv-Package in R.\n\n\nrenv\nThe renv-package is intended for simple project-local R dependency management. Here you’ll find a more thorough introduction.\n\n\nSetup\n\nCreate an RStudio Project in the working directory that should be made reproducible.\nIf another R-version should be used, switch to that version. On Windows, you can simply install multiple versions of R and switch between them in RStudio by going to Tools - Global Options - General. Maybe you will have to install renv for this version again.\nInitialise the project using renv::init(). This creates the basic infrastructure for the usage of renv.\n\n\nDependencies should be discovered automatically. It can take a while, if you’re doing this for the first time.\nIf you want to install specific package versions, you can use renv::intit(bare = TRUE).\n\nThis sets up the renv project without trying to find the used dependencies. Thus, you can install the specific versions manually afterwards.\n\nThe dependencies in the working directory can be obtained by renv::dependencies().\n\n\n\nIf you want specific package versions, you can use renv::install(packagename/@version-number). Local packages or packages from GitHub can be installed as well (see here).\nIn the end, packages should be installed in ./renv/library. A lockfile ./renv.lock is created, where the R version and the package versions are noted.\nNow you can work with the project. If you update dependencies, for example when you install and/or load new packages, you can save the state of the project library to the lockfile using renv::snapshot().\nIf you want to restore the state of the project library as noted in the lockfile, use renv::restore().\n\n\n\nProject usage\n\nFor maximal reproducibility, check the lockfile for the R-version before working with renv. If another R-version is documented in the lockfile, you can change the R-version before reproducing an analysis, see 2).\nAs the packages are directly installed into the project working directory, you should be able to simply work with the renv-project as saved by the last user without doing anything.\n\n\n\nNote on Package Versions\nMRAN can be used to get snapshots of R on any day back to 17.09.2014. Here, package versions on specific dates can be found, for example, when a script was finished on 06.05.22, the packages probably used can be obtained from here. Sometimes an error similar to this can occur:\nError: install of package 'tidyselect' failed [error code 1]\nIn this case it is possible to look up the package version on the respective date on MRAN and install this version manually. On 06.05.22, CRAN hosted Version 1.1.2 of tidyselect, so you install the version like so: renv::install(\"tidyselect@1.1.2\")."
  },
  {
    "objectID": "docs/R/ws2.html",
    "href": "docs/R/ws2.html",
    "title": "Data Frames, Listen und Grafiken in R",
    "section": "",
    "text": "Ein data.frame kann als eine spaltenweise Aneinanderreihung verschiedener Vektoren verstanden werden. Jeder einzelne Vektor kann dabei, wie gehabt, nur Elemente derselben Klasse enthalten; der data.frame selbst kann jedoch Vektoren unterschiedlicher Klasse enthalten. Im folgenden Beispiel wird ein data.frame aus zwei character- und drei numerischen Vektoren erzeugt:\n\nID &lt;- c(89045, 43678, 88475, 69781, 88766, 67743)\nname &lt;- c(\"Onno\", \"Stefan\", \"Sylvain\", \"Annette\", \"Marina\", \"Eike\")\ngeschlecht &lt;- c(\"m\",\"m\",\"m\",\"w\",\"w\",\"m\")\ntreatment  &lt;- c(0,1,1,1,0,1)\nbdi.wert   &lt;- c(12.5,13,11.75,9.85,10.15,9.95)\ndaten      &lt;- data.frame(ID, name, geschlecht, treatment, bdi.wert, stringsAsFactors=FALSE)\n\nUm sich einen Überblick über den soeben angelegten data.frame zu verschaffen, sind folgende Befehle nützlich:\n\nDie ersten Zeilen des Datensatzes werden ausgegeben:\n\n\nhead(daten)\n\n     ID    name geschlecht treatment bdi.wert\n1 89045    Onno          m         0    12.50\n2 43678  Stefan          m         1    13.00\n3 88475 Sylvain          m         1    11.75\n4 69781 Annette          w         1     9.85\n5 88766  Marina          w         0    10.15\n6 67743    Eike          m         1     9.95\n\n\n\nDie Struktur des Datensatzes wird ausgegeben:\n\n\nstr(daten)\n\n'data.frame':   6 obs. of  5 variables:\n $ ID        : num  89045 43678 88475 69781 88766 ...\n $ name      : chr  \"Onno\" \"Stefan\" \"Sylvain\" \"Annette\" ...\n $ geschlecht: chr  \"m\" \"m\" \"m\" \"w\" ...\n $ treatment : num  0 1 1 1 0 1\n $ bdi.wert  : num  12.5 13 11.75 9.85 10.15 ...\n\n\n\nEine Zusammenfassung der Daten wird ausgegeben:\n\n\nsummary(daten)\n\n       ID            name            geschlecht          treatment     \n Min.   :43678   Length:6           Length:6           Min.   :0.0000  \n 1st Qu.:68252   Class :character   Class :character   1st Qu.:0.2500  \n Median :79128   Mode  :character   Mode  :character   Median :1.0000  \n Mean   :74581                                         Mean   :0.6667  \n 3rd Qu.:88693                                         3rd Qu.:1.0000  \n Max.   :89045                                         Max.   :1.0000  \n    bdi.wert    \n Min.   : 9.85  \n 1st Qu.:10.00  \n Median :10.95  \n Mean   :11.20  \n 3rd Qu.:12.31  \n Max.   :13.00  \n\n\n\nWelche Eigenschaften hat ein Objekt “data.frame”?\n\n\nclass(daten)\n\n[1] \"data.frame\"\n\nmode(daten)\n\n[1] \"list\"\n\n\nAuf zwei Besonderheiten soll hier kurz eingegangen werden:\n\nWarum hat das Objekt daten zwar die Klasse data.frame, aber den Modus list? Der Grund ist, dass in R data.frames “Spezialfälle” von Listen sind, genauso wie man einen Skalar als “Spezialfall” eines Vektors verstehen kann. In R dürfen Listen beliebig viele Elemente beliebigen Typs enthalten. data.frames dürfen mehrere Vektoren gleicher Länge, aber unterschiedlichen Typs (bzw. unterschiedlicher Klasse) enthalten. Ein data.frame ist also eine “eingeschränkte” Liste.\nWas bedeutet “stringsAsFactors”? Wird ein data.frame konstruiert, der sich (teilweise) aus character-Variablen zusammensetzt, werden diese in R standardmäßig wie Faktoren behandelt. Das ist dann sinnvoll, wenn diese character-Variablen (wie hier) im Grunde nur Gruppierungsvariablen sind (hier: male, female). In SPSS gibt es für Gruppierungsvariablen die Skalendefinition “nominal”. Typischerweise werden solche Variablen als unabhängige Variablen in Varianzanalysen eingesetzt. Unter “echten” character-Variablen könnte man sich etwa die Freitextantworten in Fragebögen vorstellen. “stringsAsFactors” besagt also: “Soll R diese Variablen wie Faktoren behandeln oder wie echte character-Variablen?”\n\nDie Variablen Treatment und Geschlecht könnten auch Faktoren werden (was in der Regel aber eigentlich nicht nötig ist):\n\ndaten$geschlecht &lt;- as.factor(daten$geschlecht)\ndaten$treatment &lt;- as.factor(daten$treatment)\nstr(daten)\n\n'data.frame':   6 obs. of  5 variables:\n $ ID        : num  89045 43678 88475 69781 88766 ...\n $ name      : chr  \"Onno\" \"Stefan\" \"Sylvain\" \"Annette\" ...\n $ geschlecht: Factor w/ 2 levels \"m\",\"w\": 1 1 1 2 2 1\n $ treatment : Factor w/ 2 levels \"0\",\"1\": 1 2 2 2 1 2\n $ bdi.wert  : num  12.5 13 11.75 9.85 10.15 ...\n\n\n\n\nNehmen wir an, wir hätten nun einen weiteren data.frame, der die Nachnamen einiger Studienteilnehmer*innen enthält:\n\ndaten2 &lt;- data.frame(\n    ID = c(43678, 88475, 88766, 89045),\n    nachname = c(\"Tegemann\", \"Laffont\", \"Brandner\",\n                 \"Schreiner\"), stringsAsFactors = FALSE)\ndaten2\n\n     ID  nachname\n1 43678  Tegemann\n2 88475   Laffont\n3 88766  Brandner\n4 89045 Schreiner\n\n\n…und möchten diesen nun mit unseren Daten zusammenführen, dann geht das sehr flexibel mit der Funktion merge(). merge() verknüpft die Datensätze automatisch über Spalten in den beiden Datensätzen, die gleich benannt sind, in unserem Beispiel die Spalte ID:\n\ndat &lt;- merge(daten, daten2, all=TRUE)\ndat\n\n     ID    name geschlecht treatment bdi.wert  nachname\n1 43678  Stefan          m         1    13.00  Tegemann\n2 67743    Eike          m         1     9.95      &lt;NA&gt;\n3 69781 Annette          w         1     9.85      &lt;NA&gt;\n4 88475 Sylvain          m         1    11.75   Laffont\n5 88766  Marina          w         0    10.15  Brandner\n6 89045    Onno          m         0    12.50 Schreiner\n\n\nSind die Spalten mit den Schlüsselvariablen nicht gleich benannt kann man im by.x-Argument spezifizieren, wie die Variable im ersten Datensatz heißt und im by.y-Argument, wie sie im zweiten Datensatz heißt. Heißen mehrere Variablen in beiden Datensätzen gleich und man möchte nur eine dieser gleichnamigen Variablen zur Verknüpfung verwenden, spezifiziert man diese im by-Argument:\n\ndat &lt;- merge(daten, daten2, by=\"ID\", all=TRUE)\ndat\n\n     ID    name geschlecht treatment bdi.wert  nachname\n1 43678  Stefan          m         1    13.00  Tegemann\n2 67743    Eike          m         1     9.95      &lt;NA&gt;\n3 69781 Annette          w         1     9.85      &lt;NA&gt;\n4 88475 Sylvain          m         1    11.75   Laffont\n5 88766  Marina          w         0    10.15  Brandner\n6 89045    Onno          m         0    12.50 Schreiner\n\n\nWenn man zwei Datensätze untereinander schreiben möchte, müssen sie dieselbe Spaltenausdehnung haben:\n\nrbind(daten2, daten2)\n\n     ID  nachname\n1 43678  Tegemann\n2 88475   Laffont\n3 88766  Brandner\n4 89045 Schreiner\n5 43678  Tegemann\n6 88475   Laffont\n7 88766  Brandner\n8 89045 Schreiner\n\n\n…und wenn man zwei Datensätze nebeneinander schreiben möchte, müssen sie dieselbe Zeilenausdehnung haben:\n\ncbind(daten2, daten2)\n\n     ID  nachname    ID  nachname\n1 43678  Tegemann 43678  Tegemann\n2 88475   Laffont 88475   Laffont\n3 88766  Brandner 88766  Brandner\n4 89045 Schreiner 89045 Schreiner\n\n\nMöchte man viele Datensätze derselben Ausdehnung nebeneinander oder untereinander in einen data.frameschreiben, kann man die Funktion do.call() benutzen, die analog zu hier im Beispiel mit cbind() auch mit rbind() funktioniert:\n\ndo.call(\"cbind\", list(daten2, daten2, daten2, daten2))\n\n     ID  nachname    ID  nachname    ID  nachname    ID  nachname\n1 43678  Tegemann 43678  Tegemann 43678  Tegemann 43678  Tegemann\n2 88475   Laffont 88475   Laffont 88475   Laffont 88475   Laffont\n3 88766  Brandner 88766  Brandner 88766  Brandner 88766  Brandner\n4 89045 Schreiner 89045 Schreiner 89045 Schreiner 89045 Schreiner\n\n\nZum weiteren Umgang mit dem Listenformat list siehe Kapitel 2, weiter unten.\n\n\n\nÄhnlich wie in Vektoren kann man in data.frames über eckige Klammern einzelne Elemente anzeigen lassen oder verändern. Da data.frames zwei Dimensionen haben (Vektoren haben nur eine), muss man hier das Element mit [Zeile, Spalte] auswählen, also beispielsweise\n\ndat[4,2]\n\n[1] \"Sylvain\"\n\n\nAlternativ kann man mit dem Dollar-Zeichen eine Variable ansteuern:\n\ndat[4,]$name\n\n[1] \"Sylvain\"\n\n\nOder man kann den Variablennamen (mit hochgestellten Anführungszeichen) verwenden:\n\ndat[4,\"name\"]\n\n[1] \"Sylvain\"\n\n\nDie komplette “name”-Spalte gibt man aus, indem man die Zeilenbezeichnung weglässt oder alle Zeilen explizit auswählt:\n\ndat$name\n\n[1] \"Stefan\"  \"Eike\"    \"Annette\" \"Sylvain\" \"Marina\"  \"Onno\"   \n\ndat[,\"name\"]\n\n[1] \"Stefan\"  \"Eike\"    \"Annette\" \"Sylvain\" \"Marina\"  \"Onno\"   \n\ndat[1:6,\"name\"]\n\n[1] \"Stefan\"  \"Eike\"    \"Annette\" \"Sylvain\" \"Marina\"  \"Onno\"   \n\n\nAuch die Reihenfolge zu variieren, ist möglich:\n\ndat[6:1,\"name\"]\n\n[1] \"Onno\"    \"Marina\"  \"Sylvain\" \"Annette\" \"Eike\"    \"Stefan\" \n\n\nUm sich nur ausgewählte Spalten in selbst definierter Reihenfolge des Datensatzes anzusehen bzw. in einem neuen Objekt zu speichern:\n\ndat2 &lt;- dat[,c(\"name\", \"nachname\", \"bdi.wert\", \"treatment\")]\ndat2\n\n     name  nachname bdi.wert treatment\n1  Stefan  Tegemann    13.00         1\n2    Eike      &lt;NA&gt;     9.95         1\n3 Annette      &lt;NA&gt;     9.85         1\n4 Sylvain   Laffont    11.75         1\n5  Marina  Brandner    10.15         0\n6    Onno Schreiner    12.50         0\n\n\nWenn man sich nur bestimmte Subgruppen anschauen möchte:\n\nAlle Mitglieder der Kontrollgruppe:\n\n\ndat2[dat2$treatment == 0,]\n\n    name  nachname bdi.wert treatment\n5 Marina  Brandner    10.15         0\n6   Onno Schreiner    12.50         0\n\n\n\nAlle mit einem BDI-Wert größer als 10:\n\n\ndat2[dat2$bdi.wert &gt; 10,]\n\n     name  nachname bdi.wert treatment\n1  Stefan  Tegemann    13.00         1\n4 Sylvain   Laffont    11.75         1\n5  Marina  Brandner    10.15         0\n6    Onno Schreiner    12.50         0\n\n\n\nAlle in der Treatment-Gruppe und einem BDI-Wert größer als 10:\n\n\ndat2[dat2$treatment == 1 & dat2$bdi.wert &gt; 10,]\n\n     name nachname bdi.wert treatment\n1  Stefan Tegemann    13.00         1\n4 Sylvain  Laffont    11.75         1\n\n\n\nAlle in der Treatment-Gruppe oder einem BDI-Wert größer als 10:\n\n\ndat2[dat2$treatment == 1 | dat2$bdi.wert &gt; 10,]\n\n     name  nachname bdi.wert treatment\n1  Stefan  Tegemann    13.00         1\n2    Eike      &lt;NA&gt;     9.95         1\n3 Annette      &lt;NA&gt;     9.85         1\n4 Sylvain   Laffont    11.75         1\n5  Marina  Brandner    10.15         0\n6    Onno Schreiner    12.50         0\n\n\n\nAlle, deren Vorname mit “S” beginnt:\n\n\ndat2[grep(\"^S\", dat2$name),]\n\n     name nachname bdi.wert treatment\n1  Stefan Tegemann    13.00         1\n4 Sylvain  Laffont    11.75         1\n\n\n\nAlle, für die kein Nachname hinterlegt ist:\n\n\ndat2[is.na(dat2$nachname),]\n\n     name nachname bdi.wert treatment\n2    Eike     &lt;NA&gt;     9.95         1\n3 Annette     &lt;NA&gt;     9.85         1\n\n\n\nDer Datensatz ohne Personen, für die kein Nachname hinterlegt ist:\n\n\ndat2[!is.na(dat2$nachname),]\n\n     name  nachname bdi.wert treatment\n1  Stefan  Tegemann    13.00         1\n4 Sylvain   Laffont    11.75         1\n5  Marina  Brandner    10.15         0\n6    Onno Schreiner    12.50         0\n\n\noder\n\ndat2[-which(is.na(dat2$nachname)),]\n\n     name  nachname bdi.wert treatment\n1  Stefan  Tegemann    13.00         1\n4 Sylvain   Laffont    11.75         1\n5  Marina  Brandner    10.15         0\n6    Onno Schreiner    12.50         0\n\n\n\n\n\nWenn man bestimmte Werte im data.frame ersetzen möchte oder Variablen in andere Variablen umkodieren möchte, hat man verschiedene Möglichkeiten.\n\nAlle Werte im Datensatz ersetzen:\n\n\n\n\nz.B. alle fehlenden Werte durch einen bestimmten Missingcode ersetzen:\n\n\ndat2[is.na(dat2)] &lt;- \"-97\"\ndat2\n\n     name  nachname bdi.wert treatment\n1  Stefan  Tegemann    13.00         1\n2    Eike       -97     9.95         1\n3 Annette       -97     9.85         1\n4 Sylvain   Laffont    11.75         1\n5  Marina  Brandner    10.15         0\n6    Onno Schreiner    12.50         0\n\n\n\noder einen bestimmen Wert durch andere Werte oder Missings ersetzen:\n\n\ndat2[dat2==\"-97\"] &lt;- NA\ndat2\n\n     name  nachname bdi.wert treatment\n1  Stefan  Tegemann    13.00         1\n2    Eike      &lt;NA&gt;     9.95         1\n3 Annette      &lt;NA&gt;     9.85         1\n4 Sylvain   Laffont    11.75         1\n5  Marina  Brandner    10.15         0\n6    Onno Schreiner    12.50         0\n\n\n\nNeue Variablen in Abhängigkeit von anderen Variablen bilden\n\nMit der Funktion ifelse formuliert man zunächst eine Bedingung (hier alle, die einen BDI kleiner als 10 haben und gleichzeitig in der Treatment-Gruppe sind), danach gibt man durch ein Komma abgetrennt an, welche Werte in der neuen Variable stehen sollen (hier \"Treatment war wirksam\"). Durch ein weiteres Komma abgetrennt kann dann angegeben werden, was passieren soll, wenn die Bedingung nicht zutrifft. Dabei kann dort sogar ein weiteres ifelse-Statement eingefügt werden, wie hier im Beispiel, das nach genau denselben Regeln aufgebaut ist.\n\ndat2$neueVar &lt;- ifelse(test=dat2$bdi.wert &lt; 10 & dat2$treatment==1,\n                       yes=\"Treatment war wirksam\",  \n                       no = ifelse(test=dat2$bdi.wert &gt;= 10 & dat2$treatment==1,   \n                                   yes=\"Treatment nicht wirksam\",\n                                   no=\"kein Treatment\"))\ndat2\n\n     name  nachname bdi.wert treatment                 neueVar\n1  Stefan  Tegemann    13.00         1 Treatment nicht wirksam\n2    Eike      &lt;NA&gt;     9.95         1   Treatment war wirksam\n3 Annette      &lt;NA&gt;     9.85         1   Treatment war wirksam\n4 Sylvain   Laffont    11.75         1 Treatment nicht wirksam\n5  Marina  Brandner    10.15         0          kein Treatment\n6    Onno Schreiner    12.50         0          kein Treatment\n\n\nAuch kann die Funktion recode aus dem Paket car verwendet werden. Hier werden die Werte oder Wertebereiche einer Variablen umkodiert. Der Wertebereich des niedrigsten aufgetretenen Wertes bis zum Wert 10 entspricht dem hier benutzten Statement lo:10. Wie man mit allen nicht explizit erwähnten Werten verfahren möchte, kann mit dem else-Argument festlegen.\n\nlibrary(car)\n\n\ndat2$neueVar &lt;- car::recode(dat2$bdi.wert, \"lo:10='leichte Depression'; else='schwere Depression'\")\ndat2\n\n     name  nachname bdi.wert treatment            neueVar\n1  Stefan  Tegemann    13.00         1 schwere Depression\n2    Eike      &lt;NA&gt;     9.95         1 leichte Depression\n3 Annette      &lt;NA&gt;     9.85         1 leichte Depression\n4 Sylvain   Laffont    11.75         1 schwere Depression\n5  Marina  Brandner    10.15         0 schwere Depression\n6    Onno Schreiner    12.50         0 schwere Depression\n\n\n\n\n\nUnser Datensatz befindet sich im sogenannten Wide-Format. Für manche Anwendungen kann es sinnvoll sein, den Datensatz in das sogenannte Long-Format zu bringen, in dem alle Werte der Personen in einer einzigen Variablen untereinander stehen. Früher benutzte man das Paket reshape2, um einen Datensatz ins Long-Format zu bringen, was auch jetzt noch immer unkompliziert möglich ist:\n\nlibrary(reshape2)\n\n\ndatl &lt;- reshape2::melt(dat, id.vars=\"ID\")\ndatl\n\n      ID   variable     value\n1  43678       name    Stefan\n2  67743       name      Eike\n3  69781       name   Annette\n4  88475       name   Sylvain\n5  88766       name    Marina\n6  89045       name      Onno\n7  43678 geschlecht         m\n8  67743 geschlecht         m\n9  69781 geschlecht         w\n10 88475 geschlecht         m\n11 88766 geschlecht         w\n12 89045 geschlecht         m\n13 43678  treatment         1\n14 67743  treatment         1\n15 69781  treatment         1\n16 88475  treatment         1\n17 88766  treatment         0\n18 89045  treatment         0\n19 43678   bdi.wert        13\n20 67743   bdi.wert      9.95\n21 69781   bdi.wert      9.85\n22 88475   bdi.wert     11.75\n23 88766   bdi.wert     10.15\n24 89045   bdi.wert      12.5\n25 43678   nachname  Tegemann\n26 67743   nachname      &lt;NA&gt;\n27 69781   nachname      &lt;NA&gt;\n28 88475   nachname   Laffont\n29 88766   nachname  Brandner\n30 89045   nachname Schreiner\n\n\nund mit dcast() formte man den Datensatz wieder zurück:\n\nreshape2::dcast(datl, ID ~ variable)\n\n     ID    name geschlecht treatment bdi.wert  nachname\n1 43678  Stefan          m         1       13  Tegemann\n2 67743    Eike          m         1     9.95      &lt;NA&gt;\n3 69781 Annette          w         1     9.85      &lt;NA&gt;\n4 88475 Sylvain          m         1    11.75   Laffont\n5 88766  Marina          w         0    10.15  Brandner\n6 89045    Onno          m         0     12.5 Schreiner\n\n\nIn jüngerer Zeit wurden dazu recht effiziente Funktionen entwickelt, die im Paket tidyr zu finden sind. Hier wird nur rudimentär in die Benutzung dieser Funktionen eingeführt – der/die interessierte Leser/in mag sich in folgende Seite vertiefen: http://tidyr.tidyverse.org/articles/pivot.html Hierbei ist zu beachten, dass bei Benutzung des Pakets tidyr die data.frames zu anderen Objekten werden, nämlich tibbles (die aber problemlos mit der Funktion as.data.frame() wieder in data.frames zurücktransformiert werden können. Darüber hinaus weicht die zu verwendende Syntax hier deutlich von der bisher gezeigten basalen R-Syntax ab. Eine besondere Rolle spielt hier der sogenannte Pipe-Operator %&gt;%, über den hier http://www.rdocumentation.org/packages/magrittr/versions/1.0.1/topics/%25%3E%25 oder an anderer Stelle weitergelesen werden kann.\n\nlibrary(tidyr)\n\nUmstrukturierung unserer Daten ins Long-Format:\n\ndat %&gt;% pivot_longer(\n  cols=name:nachname,\n  names_to = \"variable\",\n  values_to = \"value\"\n)\n\noder, äquivalent dazu, mit:\n\npivot_longer(dat, cols=name:nachname, names_to = \"variable\", values_to = \"value\")\n\n# A tibble: 30 × 3\n      ID variable   value   \n   &lt;dbl&gt; &lt;chr&gt;      &lt;chr&gt;   \n 1 43678 name       Stefan  \n 2 43678 geschlecht m       \n 3 43678 treatment  1       \n 4 43678 bdi.wert   13      \n 5 43678 nachname   Tegemann\n 6 67743 name       Eike    \n 7 67743 geschlecht m       \n 8 67743 treatment  1       \n 9 67743 bdi.wert   9.95    \n10 67743 nachname   &lt;NA&gt;    \n# ℹ 20 more rows\n\n\nund mit pivot_wider() kann man den Datensatz wieder zurück formen:\n\ndatl  %&gt;% pivot_wider(\n  names_from = variable, values_from = value\n)\n\noder genauso:\n\npivot_wider(datl, names_from = variable, values_from = value)\n\n# A tibble: 6 × 6\n     ID name    geschlecht treatment bdi.wert nachname \n  &lt;dbl&gt; &lt;chr&gt;   &lt;chr&gt;      &lt;chr&gt;     &lt;chr&gt;    &lt;chr&gt;    \n1 43678 Stefan  m          1         13       Tegemann \n2 67743 Eike    m          1         9.95     &lt;NA&gt;     \n3 69781 Annette w          1         9.85     &lt;NA&gt;     \n4 88475 Sylvain m          1         11.75    Laffont  \n5 88766 Marina  w          0         10.15    Brandner \n6 89045 Onno    m          0         12.5     Schreiner"
  },
  {
    "objectID": "docs/R/ws2.html#zusammenführen-von-data.frames-merging",
    "href": "docs/R/ws2.html#zusammenführen-von-data.frames-merging",
    "title": "Data Frames, Listen und Grafiken in R",
    "section": "",
    "text": "Nehmen wir an, wir hätten nun einen weiteren data.frame, der die Nachnamen einiger Studienteilnehmer*innen enthält:\n\ndaten2 &lt;- data.frame(\n    ID = c(43678, 88475, 88766, 89045),\n    nachname = c(\"Tegemann\", \"Laffont\", \"Brandner\",\n                 \"Schreiner\"), stringsAsFactors = FALSE)\ndaten2\n\n     ID  nachname\n1 43678  Tegemann\n2 88475   Laffont\n3 88766  Brandner\n4 89045 Schreiner\n\n\n…und möchten diesen nun mit unseren Daten zusammenführen, dann geht das sehr flexibel mit der Funktion merge(). merge() verknüpft die Datensätze automatisch über Spalten in den beiden Datensätzen, die gleich benannt sind, in unserem Beispiel die Spalte ID:\n\ndat &lt;- merge(daten, daten2, all=TRUE)\ndat\n\n     ID    name geschlecht treatment bdi.wert  nachname\n1 43678  Stefan          m         1    13.00  Tegemann\n2 67743    Eike          m         1     9.95      &lt;NA&gt;\n3 69781 Annette          w         1     9.85      &lt;NA&gt;\n4 88475 Sylvain          m         1    11.75   Laffont\n5 88766  Marina          w         0    10.15  Brandner\n6 89045    Onno          m         0    12.50 Schreiner\n\n\nSind die Spalten mit den Schlüsselvariablen nicht gleich benannt kann man im by.x-Argument spezifizieren, wie die Variable im ersten Datensatz heißt und im by.y-Argument, wie sie im zweiten Datensatz heißt. Heißen mehrere Variablen in beiden Datensätzen gleich und man möchte nur eine dieser gleichnamigen Variablen zur Verknüpfung verwenden, spezifiziert man diese im by-Argument:\n\ndat &lt;- merge(daten, daten2, by=\"ID\", all=TRUE)\ndat\n\n     ID    name geschlecht treatment bdi.wert  nachname\n1 43678  Stefan          m         1    13.00  Tegemann\n2 67743    Eike          m         1     9.95      &lt;NA&gt;\n3 69781 Annette          w         1     9.85      &lt;NA&gt;\n4 88475 Sylvain          m         1    11.75   Laffont\n5 88766  Marina          w         0    10.15  Brandner\n6 89045    Onno          m         0    12.50 Schreiner\n\n\nWenn man zwei Datensätze untereinander schreiben möchte, müssen sie dieselbe Spaltenausdehnung haben:\n\nrbind(daten2, daten2)\n\n     ID  nachname\n1 43678  Tegemann\n2 88475   Laffont\n3 88766  Brandner\n4 89045 Schreiner\n5 43678  Tegemann\n6 88475   Laffont\n7 88766  Brandner\n8 89045 Schreiner\n\n\n…und wenn man zwei Datensätze nebeneinander schreiben möchte, müssen sie dieselbe Zeilenausdehnung haben:\n\ncbind(daten2, daten2)\n\n     ID  nachname    ID  nachname\n1 43678  Tegemann 43678  Tegemann\n2 88475   Laffont 88475   Laffont\n3 88766  Brandner 88766  Brandner\n4 89045 Schreiner 89045 Schreiner\n\n\nMöchte man viele Datensätze derselben Ausdehnung nebeneinander oder untereinander in einen data.frameschreiben, kann man die Funktion do.call() benutzen, die analog zu hier im Beispiel mit cbind() auch mit rbind() funktioniert:\n\ndo.call(\"cbind\", list(daten2, daten2, daten2, daten2))\n\n     ID  nachname    ID  nachname    ID  nachname    ID  nachname\n1 43678  Tegemann 43678  Tegemann 43678  Tegemann 43678  Tegemann\n2 88475   Laffont 88475   Laffont 88475   Laffont 88475   Laffont\n3 88766  Brandner 88766  Brandner 88766  Brandner 88766  Brandner\n4 89045 Schreiner 89045 Schreiner 89045 Schreiner 89045 Schreiner\n\n\nZum weiteren Umgang mit dem Listenformat list siehe Kapitel 2, weiter unten."
  },
  {
    "objectID": "docs/R/ws2.html#navigation-in-data.frames-subsetting",
    "href": "docs/R/ws2.html#navigation-in-data.frames-subsetting",
    "title": "Data Frames, Listen und Grafiken in R",
    "section": "",
    "text": "Ähnlich wie in Vektoren kann man in data.frames über eckige Klammern einzelne Elemente anzeigen lassen oder verändern. Da data.frames zwei Dimensionen haben (Vektoren haben nur eine), muss man hier das Element mit [Zeile, Spalte] auswählen, also beispielsweise\n\ndat[4,2]\n\n[1] \"Sylvain\"\n\n\nAlternativ kann man mit dem Dollar-Zeichen eine Variable ansteuern:\n\ndat[4,]$name\n\n[1] \"Sylvain\"\n\n\nOder man kann den Variablennamen (mit hochgestellten Anführungszeichen) verwenden:\n\ndat[4,\"name\"]\n\n[1] \"Sylvain\"\n\n\nDie komplette “name”-Spalte gibt man aus, indem man die Zeilenbezeichnung weglässt oder alle Zeilen explizit auswählt:\n\ndat$name\n\n[1] \"Stefan\"  \"Eike\"    \"Annette\" \"Sylvain\" \"Marina\"  \"Onno\"   \n\ndat[,\"name\"]\n\n[1] \"Stefan\"  \"Eike\"    \"Annette\" \"Sylvain\" \"Marina\"  \"Onno\"   \n\ndat[1:6,\"name\"]\n\n[1] \"Stefan\"  \"Eike\"    \"Annette\" \"Sylvain\" \"Marina\"  \"Onno\"   \n\n\nAuch die Reihenfolge zu variieren, ist möglich:\n\ndat[6:1,\"name\"]\n\n[1] \"Onno\"    \"Marina\"  \"Sylvain\" \"Annette\" \"Eike\"    \"Stefan\" \n\n\nUm sich nur ausgewählte Spalten in selbst definierter Reihenfolge des Datensatzes anzusehen bzw. in einem neuen Objekt zu speichern:\n\ndat2 &lt;- dat[,c(\"name\", \"nachname\", \"bdi.wert\", \"treatment\")]\ndat2\n\n     name  nachname bdi.wert treatment\n1  Stefan  Tegemann    13.00         1\n2    Eike      &lt;NA&gt;     9.95         1\n3 Annette      &lt;NA&gt;     9.85         1\n4 Sylvain   Laffont    11.75         1\n5  Marina  Brandner    10.15         0\n6    Onno Schreiner    12.50         0\n\n\nWenn man sich nur bestimmte Subgruppen anschauen möchte:\n\nAlle Mitglieder der Kontrollgruppe:\n\n\ndat2[dat2$treatment == 0,]\n\n    name  nachname bdi.wert treatment\n5 Marina  Brandner    10.15         0\n6   Onno Schreiner    12.50         0\n\n\n\nAlle mit einem BDI-Wert größer als 10:\n\n\ndat2[dat2$bdi.wert &gt; 10,]\n\n     name  nachname bdi.wert treatment\n1  Stefan  Tegemann    13.00         1\n4 Sylvain   Laffont    11.75         1\n5  Marina  Brandner    10.15         0\n6    Onno Schreiner    12.50         0\n\n\n\nAlle in der Treatment-Gruppe und einem BDI-Wert größer als 10:\n\n\ndat2[dat2$treatment == 1 & dat2$bdi.wert &gt; 10,]\n\n     name nachname bdi.wert treatment\n1  Stefan Tegemann    13.00         1\n4 Sylvain  Laffont    11.75         1\n\n\n\nAlle in der Treatment-Gruppe oder einem BDI-Wert größer als 10:\n\n\ndat2[dat2$treatment == 1 | dat2$bdi.wert &gt; 10,]\n\n     name  nachname bdi.wert treatment\n1  Stefan  Tegemann    13.00         1\n2    Eike      &lt;NA&gt;     9.95         1\n3 Annette      &lt;NA&gt;     9.85         1\n4 Sylvain   Laffont    11.75         1\n5  Marina  Brandner    10.15         0\n6    Onno Schreiner    12.50         0\n\n\n\nAlle, deren Vorname mit “S” beginnt:\n\n\ndat2[grep(\"^S\", dat2$name),]\n\n     name nachname bdi.wert treatment\n1  Stefan Tegemann    13.00         1\n4 Sylvain  Laffont    11.75         1\n\n\n\nAlle, für die kein Nachname hinterlegt ist:\n\n\ndat2[is.na(dat2$nachname),]\n\n     name nachname bdi.wert treatment\n2    Eike     &lt;NA&gt;     9.95         1\n3 Annette     &lt;NA&gt;     9.85         1\n\n\n\nDer Datensatz ohne Personen, für die kein Nachname hinterlegt ist:\n\n\ndat2[!is.na(dat2$nachname),]\n\n     name  nachname bdi.wert treatment\n1  Stefan  Tegemann    13.00         1\n4 Sylvain   Laffont    11.75         1\n5  Marina  Brandner    10.15         0\n6    Onno Schreiner    12.50         0\n\n\noder\n\ndat2[-which(is.na(dat2$nachname)),]\n\n     name  nachname bdi.wert treatment\n1  Stefan  Tegemann    13.00         1\n4 Sylvain   Laffont    11.75         1\n5  Marina  Brandner    10.15         0\n6    Onno Schreiner    12.50         0"
  },
  {
    "objectID": "docs/R/ws2.html#rekodieren-von-variablen-in-data.frames",
    "href": "docs/R/ws2.html#rekodieren-von-variablen-in-data.frames",
    "title": "Data Frames, Listen und Grafiken in R",
    "section": "",
    "text": "Wenn man bestimmte Werte im data.frame ersetzen möchte oder Variablen in andere Variablen umkodieren möchte, hat man verschiedene Möglichkeiten.\n\nAlle Werte im Datensatz ersetzen:\n\n\n\n\nz.B. alle fehlenden Werte durch einen bestimmten Missingcode ersetzen:\n\n\ndat2[is.na(dat2)] &lt;- \"-97\"\ndat2\n\n     name  nachname bdi.wert treatment\n1  Stefan  Tegemann    13.00         1\n2    Eike       -97     9.95         1\n3 Annette       -97     9.85         1\n4 Sylvain   Laffont    11.75         1\n5  Marina  Brandner    10.15         0\n6    Onno Schreiner    12.50         0\n\n\n\noder einen bestimmen Wert durch andere Werte oder Missings ersetzen:\n\n\ndat2[dat2==\"-97\"] &lt;- NA\ndat2\n\n     name  nachname bdi.wert treatment\n1  Stefan  Tegemann    13.00         1\n2    Eike      &lt;NA&gt;     9.95         1\n3 Annette      &lt;NA&gt;     9.85         1\n4 Sylvain   Laffont    11.75         1\n5  Marina  Brandner    10.15         0\n6    Onno Schreiner    12.50         0\n\n\n\nNeue Variablen in Abhängigkeit von anderen Variablen bilden\n\nMit der Funktion ifelse formuliert man zunächst eine Bedingung (hier alle, die einen BDI kleiner als 10 haben und gleichzeitig in der Treatment-Gruppe sind), danach gibt man durch ein Komma abgetrennt an, welche Werte in der neuen Variable stehen sollen (hier \"Treatment war wirksam\"). Durch ein weiteres Komma abgetrennt kann dann angegeben werden, was passieren soll, wenn die Bedingung nicht zutrifft. Dabei kann dort sogar ein weiteres ifelse-Statement eingefügt werden, wie hier im Beispiel, das nach genau denselben Regeln aufgebaut ist.\n\ndat2$neueVar &lt;- ifelse(test=dat2$bdi.wert &lt; 10 & dat2$treatment==1,\n                       yes=\"Treatment war wirksam\",  \n                       no = ifelse(test=dat2$bdi.wert &gt;= 10 & dat2$treatment==1,   \n                                   yes=\"Treatment nicht wirksam\",\n                                   no=\"kein Treatment\"))\ndat2\n\n     name  nachname bdi.wert treatment                 neueVar\n1  Stefan  Tegemann    13.00         1 Treatment nicht wirksam\n2    Eike      &lt;NA&gt;     9.95         1   Treatment war wirksam\n3 Annette      &lt;NA&gt;     9.85         1   Treatment war wirksam\n4 Sylvain   Laffont    11.75         1 Treatment nicht wirksam\n5  Marina  Brandner    10.15         0          kein Treatment\n6    Onno Schreiner    12.50         0          kein Treatment\n\n\nAuch kann die Funktion recode aus dem Paket car verwendet werden. Hier werden die Werte oder Wertebereiche einer Variablen umkodiert. Der Wertebereich des niedrigsten aufgetretenen Wertes bis zum Wert 10 entspricht dem hier benutzten Statement lo:10. Wie man mit allen nicht explizit erwähnten Werten verfahren möchte, kann mit dem else-Argument festlegen.\n\nlibrary(car)\n\n\ndat2$neueVar &lt;- car::recode(dat2$bdi.wert, \"lo:10='leichte Depression'; else='schwere Depression'\")\ndat2\n\n     name  nachname bdi.wert treatment            neueVar\n1  Stefan  Tegemann    13.00         1 schwere Depression\n2    Eike      &lt;NA&gt;     9.95         1 leichte Depression\n3 Annette      &lt;NA&gt;     9.85         1 leichte Depression\n4 Sylvain   Laffont    11.75         1 schwere Depression\n5  Marina  Brandner    10.15         0 schwere Depression\n6    Onno Schreiner    12.50         0 schwere Depression"
  },
  {
    "objectID": "docs/R/ws2.html#umstrukturieren-von-data.frames",
    "href": "docs/R/ws2.html#umstrukturieren-von-data.frames",
    "title": "Data Frames, Listen und Grafiken in R",
    "section": "",
    "text": "Unser Datensatz befindet sich im sogenannten Wide-Format. Für manche Anwendungen kann es sinnvoll sein, den Datensatz in das sogenannte Long-Format zu bringen, in dem alle Werte der Personen in einer einzigen Variablen untereinander stehen. Früher benutzte man das Paket reshape2, um einen Datensatz ins Long-Format zu bringen, was auch jetzt noch immer unkompliziert möglich ist:\n\nlibrary(reshape2)\n\n\ndatl &lt;- reshape2::melt(dat, id.vars=\"ID\")\ndatl\n\n      ID   variable     value\n1  43678       name    Stefan\n2  67743       name      Eike\n3  69781       name   Annette\n4  88475       name   Sylvain\n5  88766       name    Marina\n6  89045       name      Onno\n7  43678 geschlecht         m\n8  67743 geschlecht         m\n9  69781 geschlecht         w\n10 88475 geschlecht         m\n11 88766 geschlecht         w\n12 89045 geschlecht         m\n13 43678  treatment         1\n14 67743  treatment         1\n15 69781  treatment         1\n16 88475  treatment         1\n17 88766  treatment         0\n18 89045  treatment         0\n19 43678   bdi.wert        13\n20 67743   bdi.wert      9.95\n21 69781   bdi.wert      9.85\n22 88475   bdi.wert     11.75\n23 88766   bdi.wert     10.15\n24 89045   bdi.wert      12.5\n25 43678   nachname  Tegemann\n26 67743   nachname      &lt;NA&gt;\n27 69781   nachname      &lt;NA&gt;\n28 88475   nachname   Laffont\n29 88766   nachname  Brandner\n30 89045   nachname Schreiner\n\n\nund mit dcast() formte man den Datensatz wieder zurück:\n\nreshape2::dcast(datl, ID ~ variable)\n\n     ID    name geschlecht treatment bdi.wert  nachname\n1 43678  Stefan          m         1       13  Tegemann\n2 67743    Eike          m         1     9.95      &lt;NA&gt;\n3 69781 Annette          w         1     9.85      &lt;NA&gt;\n4 88475 Sylvain          m         1    11.75   Laffont\n5 88766  Marina          w         0    10.15  Brandner\n6 89045    Onno          m         0     12.5 Schreiner\n\n\nIn jüngerer Zeit wurden dazu recht effiziente Funktionen entwickelt, die im Paket tidyr zu finden sind. Hier wird nur rudimentär in die Benutzung dieser Funktionen eingeführt – der/die interessierte Leser/in mag sich in folgende Seite vertiefen: http://tidyr.tidyverse.org/articles/pivot.html Hierbei ist zu beachten, dass bei Benutzung des Pakets tidyr die data.frames zu anderen Objekten werden, nämlich tibbles (die aber problemlos mit der Funktion as.data.frame() wieder in data.frames zurücktransformiert werden können. Darüber hinaus weicht die zu verwendende Syntax hier deutlich von der bisher gezeigten basalen R-Syntax ab. Eine besondere Rolle spielt hier der sogenannte Pipe-Operator %&gt;%, über den hier http://www.rdocumentation.org/packages/magrittr/versions/1.0.1/topics/%25%3E%25 oder an anderer Stelle weitergelesen werden kann.\n\nlibrary(tidyr)\n\nUmstrukturierung unserer Daten ins Long-Format:\n\ndat %&gt;% pivot_longer(\n  cols=name:nachname,\n  names_to = \"variable\",\n  values_to = \"value\"\n)\n\noder, äquivalent dazu, mit:\n\npivot_longer(dat, cols=name:nachname, names_to = \"variable\", values_to = \"value\")\n\n# A tibble: 30 × 3\n      ID variable   value   \n   &lt;dbl&gt; &lt;chr&gt;      &lt;chr&gt;   \n 1 43678 name       Stefan  \n 2 43678 geschlecht m       \n 3 43678 treatment  1       \n 4 43678 bdi.wert   13      \n 5 43678 nachname   Tegemann\n 6 67743 name       Eike    \n 7 67743 geschlecht m       \n 8 67743 treatment  1       \n 9 67743 bdi.wert   9.95    \n10 67743 nachname   &lt;NA&gt;    \n# ℹ 20 more rows\n\n\nund mit pivot_wider() kann man den Datensatz wieder zurück formen:\n\ndatl  %&gt;% pivot_wider(\n  names_from = variable, values_from = value\n)\n\noder genauso:\n\npivot_wider(datl, names_from = variable, values_from = value)\n\n# A tibble: 6 × 6\n     ID name    geschlecht treatment bdi.wert nachname \n  &lt;dbl&gt; &lt;chr&gt;   &lt;chr&gt;      &lt;chr&gt;     &lt;chr&gt;    &lt;chr&gt;    \n1 43678 Stefan  m          1         13       Tegemann \n2 67743 Eike    m          1         9.95     &lt;NA&gt;     \n3 69781 Annette w          1         9.85     &lt;NA&gt;     \n4 88475 Sylvain m          1         11.75    Laffont  \n5 88766 Marina  w          0         10.15    Brandner \n6 89045 Onno    m          0         12.5     Schreiner"
  },
  {
    "objectID": "docs/R/ws2.html#subsetting-in-listen",
    "href": "docs/R/ws2.html#subsetting-in-listen",
    "title": "Data Frames, Listen und Grafiken in R",
    "section": "2.1 Subsetting in Listen",
    "text": "2.1 Subsetting in Listen\nAuch bei Listen gibt es wieder zwei Möglichkeiten, wie man auf die Elemente zugreifen kann:\n\nÜber den Index, z.B. wenn man im dritten Listenelement weitere Unterelemente ansteuern möchte, wie hier die zweite Spalte und die fünfte Zeile:\n\n\nL1[[3]][5,2]\n\n[1] \"Brandner\"\n\n\n\nÜber den Namen in Anführungszeichen oder mit vorangestelltem Dollar-Zeichen:\n\n\nL1[[\"Gesamt\"]][5,2]\n\n[1] \"Brandner\"\n\nL1[[\"Gesamt\"]][5,\"nachname\"]\n\n[1] \"Brandner\"\n\nL1$Gesamt$nachname[5]\n\n[1] \"Brandner\"\n\n\nEine Teilliste der Liste kann aufgerufen werden, indem die einzelnen Komponenten indiziert werden:\n\nL1[c(1,2)]\n\n$Werte\n[1] 12.50 13.00 11.75  9.85 10.15  9.95\n\n$Nachnamen\n[1] \"Tegemann\"  \"Laffont\"   \"Brandner\"  \"Schreiner\""
  },
  {
    "objectID": "docs/R/ws2.html#merging-von-listen",
    "href": "docs/R/ws2.html#merging-von-listen",
    "title": "Data Frames, Listen und Grafiken in R",
    "section": "2.2 Merging von Listen",
    "text": "2.2 Merging von Listen\nListen können kombiniert werden, indem sie mit c() verbunden werden:\n\nL2 &lt;- c(L1[2], L1[1])\nL2\n\n$Nachnamen\n[1] \"Tegemann\"  \"Laffont\"   \"Brandner\"  \"Schreiner\"\n\n$Werte\n[1] 12.50 13.00 11.75  9.85 10.15  9.95\n\n\nWeitere Komponenten können über Neuindizierung oder Namen hinzugefügt werden:\n\nL2[[3]] &lt;- TRUE\nL2$nochwas &lt;- FALSE\nL2[[\"undnochwas\"]] &lt;- data.frame(wahr=c(FALSE,TRUE,TRUE),falsch=c(TRUE,TRUE,FALSE))\nL2\n\n$Nachnamen\n[1] \"Tegemann\"  \"Laffont\"   \"Brandner\"  \"Schreiner\"\n\n$Werte\n[1] 12.50 13.00 11.75  9.85 10.15  9.95\n\n[[3]]\n[1] TRUE\n\n$nochwas\n[1] FALSE\n\n$undnochwas\n   wahr falsch\n1 FALSE   TRUE\n2  TRUE   TRUE\n3  TRUE  FALSE\n\n\nSollen Komponenten entfernt werden, kann man wieder den Minus-Operator benutzen:\n\nL2 &lt;- L2[-c(3,4)]\nL2\n\n$Nachnamen\n[1] \"Tegemann\"  \"Laffont\"   \"Brandner\"  \"Schreiner\"\n\n$Werte\n[1] 12.50 13.00 11.75  9.85 10.15  9.95\n\n$undnochwas\n   wahr falsch\n1 FALSE   TRUE\n2  TRUE   TRUE\n3  TRUE  FALSE"
  },
  {
    "objectID": "docs/R/ws2.html#aufheben-der-listenstruktur",
    "href": "docs/R/ws2.html#aufheben-der-listenstruktur",
    "title": "Data Frames, Listen und Grafiken in R",
    "section": "2.3 Aufheben der Listenstruktur",
    "text": "2.3 Aufheben der Listenstruktur\nMöchte man keine Liste mehr haben, hilft die Funktion unlist() weiter, die alle Elemente der Liste nacheinander in einen benannten Vektor schreibt, dessen Namen man aber auch entfernen kann:\n\n(L3 &lt;- unlist(L2))\n\n        Nachnamen1         Nachnamen2         Nachnamen3         Nachnamen4 \n        \"Tegemann\"          \"Laffont\"         \"Brandner\"        \"Schreiner\" \n            Werte1             Werte2             Werte3             Werte4 \n            \"12.5\"               \"13\"            \"11.75\"             \"9.85\" \n            Werte5             Werte6   undnochwas.wahr1   undnochwas.wahr2 \n           \"10.15\"             \"9.95\"            \"FALSE\"             \"TRUE\" \n  undnochwas.wahr3 undnochwas.falsch1 undnochwas.falsch2 undnochwas.falsch3 \n            \"TRUE\"             \"TRUE\"             \"TRUE\"            \"FALSE\" \n\nunname(unlist(L2))\n\n [1] \"Tegemann\"  \"Laffont\"   \"Brandner\"  \"Schreiner\" \"12.5\"      \"13\"       \n [7] \"11.75\"     \"9.85\"      \"10.15\"     \"9.95\"      \"FALSE\"     \"TRUE\"     \n[13] \"TRUE\"      \"TRUE\"      \"TRUE\"      \"FALSE\""
  },
  {
    "objectID": "docs/R/ws2.html#balkendiagramme",
    "href": "docs/R/ws2.html#balkendiagramme",
    "title": "Data Frames, Listen und Grafiken in R",
    "section": "1.1 Balkendiagramme",
    "text": "1.1 Balkendiagramme\nZ.B. Verteilung des BDI-Werts:\n\nbarplot(bdi.wert ~ name, data=dat2)\n\n\n\n\nFür einfache Häufigkeitsverteilungen:\n\nhist(dat2$bdi.wert)\n\n\n\n\nBoxplots:\n\nboxplot(bdi.wert ~ treatment, data=dat2)"
  },
  {
    "objectID": "docs/R/ws2.html#die-plot-funktion-und-mehrere-grafiken-neben--oder-untereinander",
    "href": "docs/R/ws2.html#die-plot-funktion-und-mehrere-grafiken-neben--oder-untereinander",
    "title": "Data Frames, Listen und Grafiken in R",
    "section": "1.2 Die plot()-Funktion und mehrere Grafiken neben- oder untereinander",
    "text": "1.2 Die plot()-Funktion und mehrere Grafiken neben- oder untereinander\nMöchte man in einem Fenster mehrere Grafiken unter- oder nebeneinander darstellen, kann man sich des Parameters mfrow der par()-Funktion bedienen. Die erste Zahl gibt an, in wie vielen Grafiken die Zeilen untereinander dargestellt werden sollen und die zweite Zahl, in wie vielen Spalten nebeneinander. Sollen die Daten zunächst geplottet werden und daneben deren Verteilung (im Beispiel nur bedingt sinnvoll), sieht das so aus:\n\npar(mfrow=c(1,2))\nplot(dat2$bdi.wert)\nplot(density(dat2$bdi.wert),main=\"Eine Verteilung\")"
  },
  {
    "objectID": "docs/R/ws2.html#das-paket-ggplot2",
    "href": "docs/R/ws2.html#das-paket-ggplot2",
    "title": "Data Frames, Listen und Grafiken in R",
    "section": "1.3 Das Paket ggplot2",
    "text": "1.3 Das Paket ggplot2\nEin mächtiges Paket zur Erstellung von Grafiken ist ggplot2, zu dem z.B. unter diesem Link eine gute Einführung gegeben wird: http://methodenlehre.github.io/einfuehrung-in-R/grafiken-mit-ggplot2.html"
  },
  {
    "objectID": "docs/R/index.html",
    "href": "docs/R/index.html",
    "title": "Material for learning R",
    "section": "",
    "text": "R Introduction\nAn introduction to R with hands on examples and exercises can be found in Introduction to R."
  },
  {
    "objectID": "docs/eatPackages/eatModel.html",
    "href": "docs/eatPackages/eatModel.html",
    "title": "eatModel",
    "section": "",
    "text": "Info\n\n\n\n\n\ncontact\nlatest version\nsource\n\n\n\n\nSebastian Weirich\nDESCRIPTION on github\ngithub page, intern\n\n\n\n\n\n\nDescription\nServes as an interface for the ConQuest software. The required control files (script, labels, data set in ‘fixed width’ format) are automatically generated and ConQuest is called via the command line. The resulting files (showfile, WLEs, PVs, etc.) can be imported back into R and edited further. Newer versions of ‘eatModel’ also allow the integration of the R package ‘tam’ and parallelisation.\n\n\n\n\n\nDocumentation\n\n\n\n\ninternal"
  },
  {
    "objectID": "docs/eatPackages/eatRecode.html",
    "href": "docs/eatPackages/eatRecode.html",
    "title": "eatRecode",
    "section": "",
    "text": "Info\n\n\n\n\n\ncontact\nlatest version\nsource\n\n\n\n\nBenjamin Becker, Nicklas Hafiz\nDESCRIPTION on github\ngithub page\n\n\n\n\n\n\nDescription\nCreate and apply recoding databases.\n\n\n\n\n\nDocumentation"
  },
  {
    "objectID": "docs/eatPackages/eatTools.html",
    "href": "docs/eatPackages/eatTools.html",
    "title": "eatTools",
    "section": "",
    "text": "Info\n\n\n\n\n\ncontact\nlatest version\nsource\n\n\n\n\nSebastian Weirich, Benjamin Becker, Karoline Sachse\nCRAN page\nCRAN page\n\n\n\n\n\n\nDescription\nVarious help functions that are also required by the packages ‘eatPrep’, ‘eatModel’, ‘eatGADS’ and ‘eatRep’, among others.\n\n\n\n\n\nDocumentation\n\n\n\n\nReference manual"
  },
  {
    "objectID": "docs/eatPackages/eatPrep.html",
    "href": "docs/eatPackages/eatPrep.html",
    "title": "eatPrep",
    "section": "",
    "text": "Info\n\n\n\n\n\ncontact\nlatest version\nsource\n\n\n\n\nKaroline Sachse\nDESCRIPTION on github\ngithub page, internal\n\n\n\n\n\n\nDescription\n“Preparation of test item data for IRT scaling using metadata provided by a predefined list structure as well as several tools and checks. Raw data can be read in and will be subjected to plausibility checks. Multiple datasets can be merged in a single step, incorporating detailed diagnostics for non-identical values among identical cases and variables. Data will be recoded according to the provided meta data, aggregated and scored. Handling different types of missing data is customizable according to user specifications. Further, missing patterns can be checked, various rater agreement measures and category discriminations can be calculated. The input metadata can be generated by the IQB-internal tool \"AnalyseInput\", which extracts item and test design information from the IQB database and formats it into a standardized xlsx file. This file can then be read by functions specifically designed for this task. Alternatively, the metadata can be provided in R-specific data formats.\n\n\n\n\n\nDocumentation\n\n\n\n\ninternal: “i:/Methoden/02_IQB-interne_eat_Workshops/eatPrep_2021”"
  },
  {
    "objectID": "docs/eatPackages/eatATA.html",
    "href": "docs/eatPackages/eatATA.html",
    "title": "eatATA",
    "section": "",
    "text": "Info\n\n\n\n\n\ncontact\nlatest version\nsource\n\n\n\n\nBenjamin Becker\nCRAN page\nCRAN page\n\n\n\n\n\n\nDescription\nAutomated block occupation/automated test booklet creation.\n\n\n\n\n\nDocumentation\n\n\n\n\ntypical use of ‘eat ATA’: a Minimal Example\n\n\n‘eatATA’ Functionality\n\n\na Pilot Study Example\n\n\nReference manual"
  },
  {
    "objectID": "docs/eatPackages/eatGADS.html",
    "href": "docs/eatPackages/eatGADS.html",
    "title": "eatGADS",
    "section": "",
    "text": "Info\n\n\n\n\n\ncontact\nlatest version\nsource\n\n\n\n\nBenjamin Becker\nCRAN page\nCRAN page\n\n\n\n\n\n\nDescription\nAllows import and data preparation of SPSS data sets in R. Generates the General Analysis Data Set (GADS) for IQB Bildungstrend studies as a SQLite3 database. Parts of the data set can then be loaded into R using the package. It also allows the export of SPSS files to and from R.\n\n\n\n\n\nDocumentation\n\n\n\n\nInfo page with several vignettes"
  },
  {
    "objectID": "docs/quarto/index.html",
    "href": "docs/quarto/index.html",
    "title": "Updating the website",
    "section": "",
    "text": "This website was created using Quarto. It is hosted on GitHub. In this chapter we will look at the underlying structure of this website, and how to update it."
  },
  {
    "objectID": "docs/quarto/index.html#setup",
    "href": "docs/quarto/index.html#setup",
    "title": "Updating the website",
    "section": "Setup",
    "text": "Setup\n\nAs the website is hosted on GitHub, you can just clone the repository.\nOpen the RStudio project with RStudio.\nThis website uses renv to keep the project specific package library up to date. The needed packages are recorded in the .lock-file, but not uploaded to GitHub. So the first thing you need to do is to install the necessary packages into your local project library:\n\n\n# install.packages(\"renv\")\nrenv::restore()\n\nIf your files need their own packages, just install them like you would normally do with either:\n\ninstall.packages(\"eatGADS\")\nrenv::install(\"eatGADS\")\n\nYou need to do this even if you have them already installed on your PC locally, because renv uses a project specific library."
  },
  {
    "objectID": "docs/quarto/index.html#file-structure",
    "href": "docs/quarto/index.html#file-structure",
    "title": "Updating the website",
    "section": "File structure",
    "text": "File structure\nBasically you just need to know where to put your files. Everything else will be taken care of by pushing to GitHub. Files can go into one of two folders: docs or posts. docs contains most of the tutorial files: They are structured into sub folders, like eatPackages or R. Here the quarto-files can be found that contain the actual website content. Edit them or add new ones. Make sure they are quarto-files with the .qmd ending.\n\n_quarto.yml\nOn the highest directory level you can find the _quarto.yml file. It defines the structure of the website. If you want your new page to be displayed in the website navigation, you have to add it here. You can define different sections and give name the links to the websites:\n    contents:\n      - section: \"R Tutorials\"\n        contents:\n          - section: \"Introduction\"\n            contents:\n             - docs/R/index.qmd\n             - href: https://nickhaf.github.io/r_tutorial/\n               text: Selfpaced R Workshop\n             - href: docs/R/ws1.qmd\n               text: Einführung\nThis creates the section R Tutorials with the subsection Introduction. Introduction consists of three pages: the index.qmd page, which is like the main page of this section, the page Selfpaced R Workshop, which actually is only a link to another website, and the page Einführung, which links to the qmd-file ws1.qmd. Just add your pages where appropriate.\n\n\nquarto-files\nThe quarto-files contain the actual content of the website. Just edit them like you would edit .qmd-files (or .rmd-files, as the rmarkdown syntax is quite similar). Here are some useful tips:\n\nLinking\nYou can easily link to other pages of this website, or to other websites:\n[displayed text](link.de)\nYou might need to use relative paths: [renv](../../posts/r_sig/23_11_06_renv/index.qmd). This will link to the renv page in the posts directory.\n\n\nPictures\nTo add a picture to your website, save the picture in the same folder as your .qmd-file. Then you can display it with:\n![](my_image.jpg)\n1\n\n\nFootnotes\nYou can add footnotes with:\nAdd a footnote[^2].\n\n[^2]: My Footnote.\nAdd a footnote2.\n\n\nCallouts\nYou can add little information boxes like this:\n::: callout-tip\nThe R-SIG meets each every two weeks on Monday from 13:00 - 14:00. The next meeting will be on 9.10.2023.\n:::\n\n\n\n\n\n\nTip\n\n\n\nThe R-SIG meets each every two weeks on Monday from 13:00 - 14:00. The next meeting will be on 9.10.2023.\n\n\nThere are multiple different options, take a look at the documentation for more.\n\n\nCSS styles\nYou can tweak the appearence even more by using you own CSS-styles.\n\n\n\nEditing on the web page\nYou can also find a small button called Edit this page next to the GitHub logo. This allows you to edit the page directly on GitHub."
  },
  {
    "objectID": "docs/quarto/index.html#building-the-website",
    "href": "docs/quarto/index.html#building-the-website",
    "title": "Updating the website",
    "section": "Building the website",
    "text": "Building the website\nTo get a preview of your website, click on the Render button in R Studio. Make sure you are not working locally and not on the network drive, because you might run into admin right problems otherwise. The rendering is not really necessary, because the website will only be built online when you push to GitHub. It will take a while (up to 20 min or more, depending on the size of the website) until the website is updated, as some checks are run first. The website will already get updated if you just open a pull request that wants to merge into main."
  },
  {
    "objectID": "docs/quarto/index.html#further-reading",
    "href": "docs/quarto/index.html#further-reading",
    "title": "Updating the website",
    "section": "Further reading",
    "text": "Further reading\nThe official documentation can be found here. A nice hands on tutorial on adding blog posts to an existing Quarto website can be found here, along with some additional tips on citations, footnotes etc."
  },
  {
    "objectID": "docs/quarto/index.html#footnotes",
    "href": "docs/quarto/index.html#footnotes",
    "title": "Updating the website",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nImage by Sinjin Thomas on Unsplash.↩︎\nMy Footnote.↩︎"
  },
  {
    "objectID": "posts/r_sig/23_03_20_forloops/index.html",
    "href": "posts/r_sig/23_03_20_forloops/index.html",
    "title": "for-loops",
    "section": "",
    "text": "1"
  },
  {
    "objectID": "posts/r_sig/23_03_20_forloops/index.html#for-loops",
    "href": "posts/r_sig/23_03_20_forloops/index.html#for-loops",
    "title": "for-loops",
    "section": "For-loops",
    "text": "For-loops\nIn this session we talked about for-loops. Take a look here for the corresponding chapter in a workshop I’ve designed."
  },
  {
    "objectID": "posts/r_sig/23_03_20_forloops/index.html#footnotes",
    "href": "posts/r_sig/23_03_20_forloops/index.html#footnotes",
    "title": "for-loops",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nImage by Tine Ivanic on Unsplash.↩︎"
  },
  {
    "objectID": "posts/r_sig/23_10_09_cleaner/index.html",
    "href": "posts/r_sig/23_10_09_cleaner/index.html",
    "title": "Cleaner Scripts",
    "section": "",
    "text": "Markdown vs. Quarto vs. R-Skripte\n\n\nQuarto is more up to date than R-Markdown\nMarkdown has more dependencies, so I would now use .R-Scripts instead, if I don’t need the markdown features.\nIn the end it’s a question of preference.\n\n\nWrite packages on top of the script.\n\n\nWrite down verion number (use sessionInfo()).\nOr, even better: use renv."
  },
  {
    "objectID": "posts/r_sig/23_10_09_cleaner/index.html#some-general-take-aways",
    "href": "posts/r_sig/23_10_09_cleaner/index.html#some-general-take-aways",
    "title": "Cleaner Scripts",
    "section": "",
    "text": "Markdown vs. Quarto vs. R-Skripte\n\n\nQuarto is more up to date than R-Markdown\nMarkdown has more dependencies, so I would now use .R-Scripts instead, if I don’t need the markdown features.\nIn the end it’s a question of preference.\n\n\nWrite packages on top of the script.\n\n\nWrite down verion number (use sessionInfo()).\nOr, even better: use renv."
  },
  {
    "objectID": "posts/newsletter/23_08_09/index.html",
    "href": "posts/newsletter/23_08_09/index.html",
    "title": "09-08-2023",
    "section": "",
    "text": "eatGADS\nDie Funktion insertVariable() wurde in relocateVariable() umbenannt. Die Funktion erlaubt die Einsortierung einer Variable innerhalb eines GADSdat-Ojekts, nun auch ganz an den Anfang eines Datensatzes.\nEine neue Funktion, recodeNA2missing(), erlaubt es NAs (in SPSS auch Sysmis genannt) automatisch in spezifische Missing Codes umzuwandeln (z.B. -99 = \"Missing By Design\").\nDie Funktion emptyTheseVariables() erlaubt es nun, mehrere Variablen gleichzeitig zu leeren (= auf NA zu setzen), was z.B. aus Datenschutzgründen relevant sein kann.\nBesonders hervoheben möchten wir an dieser Stelle noch die Funktion fixEncoding(), die es erlaubt, automatisch Umlaute und Sonderzeichen aus Variablennamen, Variablen- und Wertelabeln, sowie Variablen an sich zu entfernen (z.B. “ü” wird zu “ue”).\nDie Dokumentation des Pakets ist nun übrigens leicht einsehbar hier zu finden.\nAlle Änderungen finden sich wie immer erst einmal in der Github-Version des Pakets."
  },
  {
    "objectID": "posts_newsletter.html",
    "href": "posts_newsletter.html",
    "title": "Newsletter",
    "section": "",
    "text": "12-01-2024\n\n\nNewsletter\n\n\n\nNicklas Hafiz\n\n\nDec 1, 2024\n\n\n\n\n\n\n\n\n\n\n\n\n09-08-2023\n\n\nNewsletter\n\n\n\nBenjamin Becker\n\n\nSep 8, 2023\n\n\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "IQB Methods Team",
    "section": "",
    "text": "This website hosts all kind of material around R, programming, statistics and psychological methods."
  },
  {
    "objectID": "posts_r_sig.html",
    "href": "posts_r_sig.html",
    "title": "R-SIG",
    "section": "",
    "text": "Order By\n       Default\n         \n          Date - Oldest\n        \n         \n          Date - Newest\n        \n         \n          Title\n        \n         \n          Author\n        \n     \n  \n    \n      \n      \n    \n\n\n\n\n\n\n\n\nDate\n\n\nTitle\n\n\nAuthor\n\n\nReading Time\n\n\n\n\n\n\n\n\n\nDec 18, 2023\n\n\nCase_when() function\n\n\nNicklas Hafiz\n\n\n5 min\n\n\n\n\n\n\n\nOct 23, 2023\n\n\nReproducability with renv\n\n\nNicklas Hafiz\n\n\n2 min\n\n\n\n\n\n\n\nOct 9, 2023\n\n\nCleaner Scripts\n\n\nNicklas Hafiz\n\n\n1 min\n\n\n\n\n\n\n\nJul 31, 2023\n\n\nThe apply family\n\n\nNicklas Hafiz\n\n\n4 min\n\n\n\n\n\n\n\nMar 20, 2023\n\n\nfor-loops\n\n\nNicklas Hafiz\n\n\n1 min\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "posts/newsletter/24_01_12/index.html",
    "href": "posts/newsletter/24_01_12/index.html",
    "title": "12-01-2024",
    "section": "",
    "text": "Webseite\nDas Methoden-Team hat jetzt eine eigene Webseite, auf der das gesamte Material vom Methoden-Team gesammelt werden soll. Das betrifft vor allem Tutorials und Workshop-Material, Infos zu den verschiedenen eat-Paketen, Zusammenfassungen aus der R-SIG, den Newsletter und vieles mehr. Aktuell sind wir noch dabei, Material zusammenzutragen, schaut aber gerne schon einmal vorbei:\nhttps://iqb-research.github.io/IQB-Methods/\n\n\nAnsprechpartner:innen während Benjamins Elternzeit\nBenjamin als Hauptverantwortlicher für die folgenden Pakete wird nun temporär durch die genannten Personen als Ansprechpartner:innen bei Problemen und Bugs aber auch Feature Requests u.ä. vertreten:\n\nGADS BT22 - Sebastian\nFDZ Reporting - Nicklas\neatFDZ - Karoline\neatGADS - Philipp\n\n\n\neatTools\nDie Version 0.7.5 liegt nun auf CRAN und beinhaltet hauptsächlich kleinere Bugfixes in den Funktionen halveString() und mergeAttr(). Wenn ihr eine ältere Version habt, ist eine Aktualisierung nicht zwingend notwendig, aber empfehlenswert, u.a., weil damit auch Fehlermeldungen in anderen eat-Paketen etwas instruktiver und leichter verständlich werden."
  },
  {
    "objectID": "posts/r_sig/23_11_06_renv/index.html",
    "href": "posts/r_sig/23_11_06_renv/index.html",
    "title": "Reproducability with renv",
    "section": "",
    "text": "Package versions will change over time. The same goes for R versions. As a consequence, they might work different in the future, which can make it difficult to reproduce your scripts. Therefore it is considered good practice to note down the package and R-versions you use. The package renv can help you with that."
  },
  {
    "objectID": "posts/r_sig/23_11_06_renv/index.html#motivation",
    "href": "posts/r_sig/23_11_06_renv/index.html#motivation",
    "title": "Reproducability with renv",
    "section": "",
    "text": "Package versions will change over time. The same goes for R versions. As a consequence, they might work different in the future, which can make it difficult to reproduce your scripts. Therefore it is considered good practice to note down the package and R-versions you use. The package renv can help you with that."
  },
  {
    "objectID": "posts/r_sig/23_11_06_renv/index.html#workflow",
    "href": "posts/r_sig/23_11_06_renv/index.html#workflow",
    "title": "Reproducability with renv",
    "section": "Workflow",
    "text": "Workflow\nFirst, initialize the project:\n\n# install.packages(renv)\nrenv::init()\n\nThis mainly will do two things:\n\nCreate a project specific package library, which contains all the packages currently used by the project. This means different projects can use different package versions.\nA .lock file, where the package versions get documented.\n\nBy the way, it doesn’t matter if you do this in the beginning of your project, in between or at the end. renv::init() will automatically setup the project with all the packages you have used in the project.\nThe rest of your workflow is pretty similar to what you are used to: If you need a new package for you project, you install it like you normally would. You can also use renv::install() which has some additional features compared to install.packages()). For example, you can install specific package versions: renv::install(\"dplyr@1.1.1\"). No matter which one you use: The package will be installed into a global cache, and a link to that package will be put into your project specific library. Then you load your package like you normally would with library().\nThe next step is to write the package into your .lock file:\n\nrenv::snapshot()\n\nThis will update the .lock file with your new package.\nIf on the other hand you want to restore the packages from the .lock file, use:\n\nrenv::restore()\n\nThis will install the package version that is documented in the lock file into your project specific library.\nYou can update your dependencies to the latest version using:\n\nrenv::update()\n\nLook here for the offical documentation."
  },
  {
    "objectID": "posts/r_sig/23_12_18_case_when/index.html",
    "href": "posts/r_sig/23_12_18_case_when/index.html",
    "title": "Case_when() function",
    "section": "",
    "text": "The case_when() function from the dplyr package of the tidyverse is a useful function for combining multiple ifelse() statements."
  },
  {
    "objectID": "posts/r_sig/23_12_18_case_when/index.html#how-to-use-it",
    "href": "posts/r_sig/23_12_18_case_when/index.html#how-to-use-it",
    "title": "Case_when() function",
    "section": "How to use it",
    "text": "How to use it\nLet’s take a look at a little example. Let’s consider a very simple data frame containing only a column of different countries:\n\nlibrary(dplyr)\n\n\nAttaching package: 'dplyr'\n\n\nThe following objects are masked from 'package:stats':\n\n    filter, lag\n\n\nThe following objects are masked from 'package:base':\n\n    intersect, setdiff, setequal, union\n\ndf &lt;- data.frame(country = c(rep(\"Deu\", 4), \"Mexico\", \"Peru\", \"Ghana\", \"China\", \"Spanien\"))\n\nNow, let’s suppose we want to add a second column containing the continent of the country. We can either use nested ifelse() statements, which makes the coed quite hard to read:\n\ndf$continent &lt;- ifelse(df$country %in% c(\"Deu\", \"Spanien\"), \n                       yes = \"Europe\", \n                       no = ifelse(\n                         df$country == \"Mexico\" | df$country == \"Peru\", \n                         yes = \"America\",\n                         no = ifelse(\n                           df$country == \"Ghana\", \n                           yes = \"Africa\",\n                           no = \"Asia\"\n                       )\n                       ))\n\ndf\n\n  country continent\n1     Deu    Europe\n2     Deu    Europe\n3     Deu    Europe\n4     Deu    Europe\n5  Mexico   America\n6    Peru   America\n7   Ghana    Africa\n8   China      Asia\n9 Spanien    Europe\n\n\ncase_when() has a slightly different syntax, but is not nested, which makes it easier to read. Condition and output are seperated by ~. So if the condition on the left side is met in a row, the function returns the value on the right side of ~:\n\ndf_2 &lt;- df %&gt;%\n  mutate(continent = case_when(country %in% c(\"Deu\", \"Spanien\") ~ \"Europe\", \n                               country %in% c(\"Mexico\", \"Peru\") ~ \"America\",\n                               country == \"Ghana\" ~ \"Africa\", \n                               TRUE ~ \"Another continent\"\n                                 )\n         )\ndf_2\n\n  country         continent\n1     Deu            Europe\n2     Deu            Europe\n3     Deu            Europe\n4     Deu            Europe\n5  Mexico           America\n6    Peru           America\n7   Ghana            Africa\n8   China Another continent\n9 Spanien            Europe\n\n\nWe wrap this statement into a mutate function to automatically create the new column continent from the output of case_when. The TRUE in the last row catches all conditions we haven’t dealt with further above. So all rows wich haven’t met any of the above conditions will get the label “Another continent”."
  },
  {
    "objectID": "posts/r_sig/23_12_18_case_when/index.html#evaluation-order",
    "href": "posts/r_sig/23_12_18_case_when/index.html#evaluation-order",
    "title": "Case_when() function",
    "section": "Evaluation order",
    "text": "Evaluation order\ncase_when() goes from the top to the bottom. So if a row has met a statement, it is not considered further down. That’s why it makes sense to go from the most specific statements to the less specific ones. Otherwise the least specific ones might overwrite everything in the beginning:\n\ndf_3 &lt;- df %&gt;%\n  mutate(continent = case_when(country %in% c(df$country) ~ \"Other country\", \n                               country %in% c(\"Mexico\", \"Peru\") ~ \"America\",\n                               country == \"Ghana\" ~ \"Africa\", \n                               TRUE ~ \"Another continent\"\n                                 )\n         )\n\ndf_3  \n\n  country     continent\n1     Deu Other country\n2     Deu Other country\n3     Deu Other country\n4     Deu Other country\n5  Mexico Other country\n6    Peru Other country\n7   Ghana Other country\n8   China Other country\n9 Spanien Other country\n\n\nBecause our first statement already covers all rows, the rest is obsolete. This top-down working also makes the TRUE condition in our last line possible, because only those rows that haven’t been used yet will come this far, and all of them are catched (because TRUE always is true)."
  },
  {
    "objectID": "posts/r_sig/23_07_31_apply/index.html",
    "href": "posts/r_sig/23_07_31_apply/index.html",
    "title": "The apply family",
    "section": "",
    "text": "I can highly recommend the according chapter in R for Data Science in case you want to dive deeper."
  },
  {
    "objectID": "posts/r_sig/23_07_31_apply/index.html#for-loops",
    "href": "posts/r_sig/23_07_31_apply/index.html#for-loops",
    "title": "The apply family",
    "section": "For-loops",
    "text": "For-loops\nIn the last SIG we talked about for-loops.\nWhile for is definitely the most flexible of the looping options, we suggest you avoid it wherever you can, for the following two reasons:\n\n\nIt is not very expressive, i.e. takes a lot of code to do what you want.\n\n\nIt permits you to write horrible code.\n\n\nLet’s consider this example:\n\nexample_list &lt;- list(\n  \"vec_1\" = c(1:10),\n  \"vec_2\" = c(100:400),\n  \"vec_3\" = c(80:97, NA)\n)\nstr(example_list)\n\nList of 3\n $ vec_1: int [1:10] 1 2 3 4 5 6 7 8 9 10\n $ vec_2: int [1:301] 100 101 102 103 104 105 106 107 108 109 ...\n $ vec_3: int [1:19] 80 81 82 83 84 85 86 87 88 89 ...\n\n\nHere we have a list consisting of three vectors. Our goal is to sum them an output the result into a new vector. We could use a for-loop to do that:\n\nvec_sum &lt;- c()\nfor(i in 1: length(example_list)){\n  vec_sum[i] &lt;- sum(example_list[[i]], na.rm = TRUE)\n}\nvec_sum\n\n[1]    55 75250  1593\n\n\nOkay, that doesn’t look that complicated. But still, we need to define an empty vector at the beginning so we can save our sums, we need to iterate from 1:length(example_list), and manually select the \\(i^{th}\\) from the input list. That is not very expressive, and can be solved a lot easier. Enter, the apply-family:"
  },
  {
    "objectID": "posts/r_sig/23_07_31_apply/index.html#the-apply-family",
    "href": "posts/r_sig/23_07_31_apply/index.html#the-apply-family",
    "title": "The apply family",
    "section": "The apply-family",
    "text": "The apply-family\nThe apply-functions apply a function to a vector, list, matrix … and also always return a vector, list matrix …, depending on the specific function. Let’s rewrite our for-loop with sapply():\n\nvec_sum &lt;- sapply(example_list, sum)\nvec_sum\n\nvec_1 vec_2 vec_3 \n   55 75250    NA \n\n\nA lot less code and easier to understand! We just go over every list element and calculate its sum.\nIf we want to add another function argument, we can do that as well:\n\nvec_sum &lt;- sapply(example_list, sum, na.rm = TRUE)\nvec_sum\n\nvec_1 vec_2 vec_3 \n   55 75250  1593 \n\n\nWe can also define our own function:\n\nvec_sum &lt;- sapply(example_list, function(x){\n  res_sum &lt;- sum(x, na.rm = TRUE)\n  print(res_sum)\n  return(res_sum)\n})\n\n[1] 55\n[1] 75250\n[1] 1593\n\n\nHere we calculate the sum of object x, and then print it.\nFinally, which makes for even nicer code, we can define the function externally, to give it a concise name:\n\nprint_sum &lt;- function(vec){\n  res_sum &lt;- sum(vec, na.rm = TRUE)\n  print(res_sum)\n  return(res_sum)\n}\n\nvec_sum &lt;- sapply(example_list, print_sum)\n\n[1] 55\n[1] 75250\n[1] 1593\n\nvec_sum\n\nvec_1 vec_2 vec_3 \n   55 75250  1593 \n\n\nDepending of the output we want, we can choose different apply-functions:\n\nsapply()\nsapply() simplifies the result, so, e.g., it will return a vector if possible:\n\nsapply(example_list, print_sum)\n\n[1] 55\n[1] 75250\n[1] 1593\n\n\nvec_1 vec_2 vec_3 \n   55 75250  1593 \n\n\n\n\nvapply()\nSimilar to sapply(), but we can pre-specify a return value, so it might be safer to use:\n\nvapply(example_list, print_sum, integer(1))\n\n[1] 55\n[1] 75250\n[1] 1593\n\n\nvec_1 vec_2 vec_3 \n   55 75250  1593 \n\n\nBecause the result is an integer vector, we don’t get an error, but if we write this:\n\nvapply(example_list, print_sum, character(1))\n\n[1] 55\n\n\nError in vapply(example_list, print_sum, character(1)): values must be type 'character',\n but FUN(X[[1]]) result is type 'integer'\n\n\nThe function returns an error, because its output is an integer, and not a character vector.\n\n\nlapply()\nReturns a list:\n\nlapply(example_list, print_sum)\n\n[1] 55\n[1] 75250\n[1] 1593\n\n\n$vec_1\n[1] 55\n\n$vec_2\n[1] 75250\n\n$vec_3\n[1] 1593\n\n\n\n\n\n\n\n\nExercises\n\n\n\nWork with the iris data.frame (it is already included in Base R):\n\nExercise 1\nWrite a for-loop to determine the median of each column, if it is numeric. If not, return the column class with class(). Save the results in a character vector, so every element should be converted to character before saving it in the vector.\n\n\n\n\n\n\nCaution\n\n\n\n\n\n\nvec_median &lt;- c()\nfor(i in 1:ncol(iris)){\n  if(is.numeric(iris[, i])){\n    vec_median[i] &lt;- as.character(median(iris[, i], na.rm = TRUE))\n  } else{\n    vec_median[i] &lt;- class(iris[, i])\n  }\n}\n\nvec_median\n\n[1] \"5.8\"    \"3\"      \"4.35\"   \"1.3\"    \"factor\"\n\n\n\n\n\n\n\nExercise 2\n\nDefine the body of the for loop as its own function. This function should take a vector, and, if this vector is numeric, output the median as a character, otherwise the class of the vector.\n\n\n\n\n\n\n\nCaution\n\n\n\n\n\n\ncheck_median &lt;- function(vec){\n  if(is.numeric(vec)){\n    result &lt;- median(vec, na.rm = TRUE)\n  } else{\n    result &lt;- class(vec)\n  }\n  ## Convert to character, so our function always returns the correct type\n  result &lt;- as.character(result)\n  return(result)\n}\n\n## Check it:\ncheck_median(c(100, 1000))\n\n[1] \"550\"\n\ncheck_median(c(\"a\", \"b\"))\n\n[1] \"character\"\n\n\n\n\n\n\nUse it in the for-loop.\n\n\n\n\n\n\n\nCaution\n\n\n\n\n\n\nvec_median &lt;- c()\nfor(i in 1:ncol(iris)){\n  vec_median[i] &lt;- check_median(iris[, i])\n}\n\nvec_median\n\n[1] \"5.8\"    \"3\"      \"4.35\"   \"1.3\"    \"factor\"\n\n\n\n\n\n\n\nExercise 3\nRewrite the for-loop from Exercise 1 with functions from the apply-family, so it returns the following objects. Define the function that gets applied on every input element externally, so we have cleaner code.\n\nA vector.\n\n\n\n\n\n\n\nCaution\n\n\n\n\n\n\nsapply(iris, check_median)\n\nSepal.Length  Sepal.Width Petal.Length  Petal.Width      Species \n       \"5.8\"          \"3\"       \"4.35\"        \"1.3\"     \"factor\" \n\n\nOr, even better:\n\nvapply(iris, check_median, character(1))\n\nSepal.Length  Sepal.Width Petal.Length  Petal.Width      Species \n       \"5.8\"          \"3\"       \"4.35\"        \"1.3\"     \"factor\" \n\n\nWow, that’s pretty nice, we condensed our function to half a line by defining the function somewhere else, and not using a for-loop!\n\n\n\n\nA list.\n\n\n\n\n\n\n\nCaution\n\n\n\n\n\n\nlapply(iris, check_median)\n\n$Sepal.Length\n[1] \"5.8\"\n\n$Sepal.Width\n[1] \"3\"\n\n$Petal.Length\n[1] \"4.35\"\n\n$Petal.Width\n[1] \"1.3\"\n\n$Species\n[1] \"factor\""
  },
  {
    "objectID": "posts/r_sig/23_07_31_apply/index.html#exercise-2",
    "href": "posts/r_sig/23_07_31_apply/index.html#exercise-2",
    "title": "The apply family",
    "section": "Exercise 2",
    "text": "Exercise 2\n\nDefine the body of the for loop as its own function. This function should take a vector, and, if this vector is numeric, output the median as a character, otherwise the class of the vector.\n\n\n\n\n\n\n\nCaution\n\n\n\n\n\n\ncheck_median &lt;- function(vec){\n  if(is.numeric(vec)){\n    result &lt;- median(vec, na.rm = TRUE)\n  } else{\n    result &lt;- class(vec)\n  }\n  ## Convert to character, so our function always returns the correct type\n  result &lt;- as.character(result)\n  return(result)\n}\n\n## Check it:\ncheck_median(c(100, 1000))\n\n[1] \"550\"\n\ncheck_median(c(\"a\", \"b\"))\n\n[1] \"character\"\n\n\n\n\n\n\nUse it in the for-loop.\n\n\n\n\n\n\n\nCaution\n\n\n\n\n\n\nvec_median &lt;- c()\nfor(i in 1:ncol(iris)){\n  vec_median[i] &lt;- check_median(iris[, i])\n}\n\nvec_median\n\n[1] \"5.8\"    \"3\"      \"4.35\"   \"1.3\"    \"factor\""
  },
  {
    "objectID": "posts/r_sig/23_07_31_apply/index.html#exercise-3",
    "href": "posts/r_sig/23_07_31_apply/index.html#exercise-3",
    "title": "The apply family",
    "section": "Exercise 3",
    "text": "Exercise 3\nRewrite the for-loop from Exercise 1 with functions from the apply-family, so it returns the following objects. Define the function that gets applied on every input element externally, so we have cleaner code.\n\nA vector.\n\n\n\n\n\n\n\nCaution\n\n\n\n\n\n\nsapply(iris, check_median)\n\nSepal.Length  Sepal.Width Petal.Length  Petal.Width      Species \n       \"5.8\"          \"3\"       \"4.35\"        \"1.3\"     \"factor\" \n\n\nOr, even better:\n\nvapply(iris, check_median, character(1))\n\nSepal.Length  Sepal.Width Petal.Length  Petal.Width      Species \n       \"5.8\"          \"3\"       \"4.35\"        \"1.3\"     \"factor\" \n\n\nWow, that’s pretty nice, we condensed our function to half a line by defining the function somewhere else, and not using a for-loop!\n\n\n\n\nA list.\n\n\n\n\n\n\n\nCaution\n\n\n\n\n\n\nlapply(iris, check_median)\n\n$Sepal.Length\n[1] \"5.8\"\n\n$Sepal.Width\n[1] \"3\"\n\n$Petal.Length\n[1] \"4.35\"\n\n$Petal.Width\n[1] \"1.3\"\n\n$Species\n[1] \"factor\""
  },
  {
    "objectID": "docs/git/index.html",
    "href": "docs/git/index.html",
    "title": "Pull requests with Github",
    "section": "",
    "text": "When people collaboratively develop software (R packages) and use Github as a repository, colleagues can review software parts before they are included in an updated package version. Since I always forget how the workflow for this works, I’ll write it down here step by step. These steps refer to the use of GitKraken; if you do this in RStudio, it may work differently."
  },
  {
    "objectID": "docs/git/index.html#following-steps-are-necessary",
    "href": "docs/git/index.html#following-steps-are-necessary",
    "title": "Pull requests with Github",
    "section": "Following steps are necessary",
    "text": "Following steps are necessary\n\nA change has been made in the local repository (on your local hard disc copy of the repository).\nThe change is committed in GitKraken, but not yet pushed.\nInstead, right-click on “master” to open a menu and select “create branch here”.\nAssign a name for this branch.\nPush by pressing “Push”.\nChange to the the Github page of the package (for example, eatTools repository) and start the pull request via “Compare & pull request”.\nChoose your favorite reviewer under “Reviewer”\nIf necessary, enter a comment for the request.\nClick on “create pull request” to start the request.\nOnce the author and reviewer have reached an agreement, the review branch can be merged with the master branch (this is not done in GitKraken, but on the GitHub website: select the pull request, scroll down the page and click on “merge pull request into master”)\nFinally, the review branch can be deleted. Choose “delete” on the Github homepage. Then delete the local branch (i.e. in GitKraken) in the same way if necessary"
  },
  {
    "objectID": "docs/git/index.html#please-note",
    "href": "docs/git/index.html#please-note",
    "title": "Pull requests with Github",
    "section": "Please note",
    "text": "Please note\nAs long as the master branch and the new branch are not merged again, there are two “parallel” branches. The background to this is that - as long as developers are working in the new branch - users can always download the latest working version (i.e. the master branch) of the package. As a developer, you always have to check in GitKraken which branch is currently stored in your local repository. If you need to make changes in the new branch, you must first save it locally by double-clicking on the relevant branch."
  },
  {
    "objectID": "docs/eatPackages/eatPlot.html",
    "href": "docs/eatPackages/eatPlot.html",
    "title": "eatPlot",
    "section": "",
    "text": "Info\n\n\n\n\n\ncontact\nlatest version\nsource\n\n\n\n\nNicklas Hafiz, Philipp Franikowski\nDESCRIPTION on github\ngithub page\n\n\n\n\n\n\nDescription\nCreating plots from the eatRep output (main use: Bilduntstrend).\nDokumentation:\n\n\n\n\n\nDocumentation\n\n\n\n\nInfo page with several vignettes"
  },
  {
    "objectID": "docs/eatPackages/index.html",
    "href": "docs/eatPackages/index.html",
    "title": "Info on eat Packages",
    "section": "",
    "text": "see table down below and click on the links for more information on a package."
  },
  {
    "objectID": "docs/eatPackages/index.html#internal-iqb-r-packages-from-the-eat-family",
    "href": "docs/eatPackages/index.html#internal-iqb-r-packages-from-the-eat-family",
    "title": "Info on eat Packages",
    "section": "internal IQB R packages from the ‘eat’-family",
    "text": "internal IQB R packages from the ‘eat’-family\nIn order to standardise and simplify the evaluation of the VERA pilot studies and the IQB educational trend, a number of R packages with the prefix eat (“educational assessment tools”) are continuously (further) developed. Currently, the following packages are maintained at the IQB:\n\n\n\n\n\npackage name\nbrief description\ncontact\n\n\n\n\neatPrep\nPreparation of data sets.\nKaroline Sachse\n\n\neatModel\nInterface for ConQuest software.\nSebastian Weirich\n\n\neatRep\ncalculates characteristics for data with clustered multi-level structures with imputed data.\nSebastian Weirich, Benjamin Becker\n\n\neatGADS\nImport and data preparation of SPSS data sets in R.\nBenjamin Becker\n\n\neatTools\nVarious help functions that are also required by the packages ‘eatPrep’, ‘eatModel’, ‘eatGADS’ and ‘eatRep’, among others.\nSebastian Weirich, Benjamin Becker, Karoline Sachse\n\n\neatAnalysis\nVarious useful help functions, such as saving Excel files, saving analysis results from lm4 and simulating IRT responses.\nBenjamin Becker, Sebastian Weirich, Karoline Sachse\n\n\neatATA\nAutomated block occupation/automated test booklet creation.\nBenjamin Becker\n\n\neatFDZ\nAutomated anonymisation of data sets, matching of pdf documents (e.g. scale manuals) and data sets.\nBenjamin Becker\n\n\neatCodebook\nAutomated creation of scale manuals.\nBenjamin Becker\n\n\neatRecode\nCreate and apply recoding databases.\nBenjamin Becker, Nicklas Hafiz\n\n\neatPlot\nCreating plots from the eatRep output (main use: Bilduntstrend).\nNicklas Hafiz, Philipp Franikowski"
  },
  {
    "objectID": "docs/eatPackages/index.html#installing-r-packages",
    "href": "docs/eatPackages/index.html#installing-r-packages",
    "title": "Info on eat Packages",
    "section": "Installing R packages",
    "text": "Installing R packages\nDetailed instructions for installing the R packages can be found here: installing R packages"
  },
  {
    "objectID": "docs/eatPackages/index.html#compatibility",
    "href": "docs/eatPackages/index.html#compatibility",
    "title": "Info on eat Packages",
    "section": "Compatibility",
    "text": "Compatibility\nMost packages of the “eat” family are not executable in isolation, which means that a package is usually dependent on another package in order to be executable. This means:\n\n“eatTools” is a package with help functions required by other packages. “eatTools” does not depend on other “eat” packages.\neatPrep” requires “eatTools”.\neatRep” needs “eatTools” and “eatGADS”.\neatModel” requires “eatTools” and “eatRep” (and thus also “eatGADS”). The package optionally accesses the computer programme Conquest or the R package “TAM” for parameter estimation. For Conquest, the command line executable is sufficient, e.g. “console_Feb2007.exe”; “TAM” is installed when the package is loaded. “TAM” and Conquest are based on the same statistical measurement model, and overlap considerably in their range of functions.\n“eatGADS” requires “eatTools” and “eatDB”.\n\nThe interdependence also extends to different versions of the packages. For example, old versions of “eatRep” are not always compatible with new versions of “eatTools” (and vice versa). The current package versions (see table above) should be compatible with each other. Usually (but not always) version conflicts are indicated by an error message. It is recommended to always have the latest package versions installed.\nSince individual functions have also changed substantially in the course of the package development, it may no longer be possible to replicate past analyses with new package versions and the identical script (e.g. from the Ländervergleich 2011). In this case, the old script would either have to be adapted or the package versions used at that time would have to be restored."
  },
  {
    "objectID": "docs/eatPackages/eatFDZ.html",
    "href": "docs/eatPackages/eatFDZ.html",
    "title": "eatFDZ",
    "section": "",
    "text": "Info\n\n\n\n\n\ncontact\nlatest version\nsource\n\n\n\n\nBenjamin Becker\nDESCRIPTION on github\ngithub page\n\n\n\n\n\n\nDescription\nAutomated anonymisation of data sets; comparison of pdf documents (e.g. scale manuals) and data sets.\n\n\n\n\n\nDocumentation"
  },
  {
    "objectID": "docs/eatPackages/eatCodebook.html",
    "href": "docs/eatPackages/eatCodebook.html",
    "title": "eatCodebook",
    "section": "",
    "text": "Info\n\n\n\n\n\ncontact\nlatest version\nsource\n\n\n\n\nBenjamin Becker\nDESCRIPTION on github\ngithub page\n\n\n\n\n\n\nDescription\nAutomated creation of scale manuals.\n\n\n\n\n\nDocumentation\n\n\n\n\nInfo page with several vignettes"
  },
  {
    "objectID": "docs/eatPackages/eatAnalysis.html",
    "href": "docs/eatPackages/eatAnalysis.html",
    "title": "eatAnalysis",
    "section": "",
    "text": "Info\n\n\n\n\n\ncontact\nlatest version\nsource\n\n\n\n\nBenjamin Becker, Sebastian Weirich, Karoline Sachse\nDESCRIPTION on github\ngithub page\n\n\n\n\n\n\nDescription\nVarious useful help functions, such as saving Excel files, saving analysis results from lm4 and simulating IRT responses.\n\n\n\n\n\nDocumentation\n\n\n\n\n-"
  },
  {
    "objectID": "docs/eatPackages/eatRep.html",
    "href": "docs/eatPackages/eatRep.html",
    "title": "eatRep",
    "section": "",
    "text": "Info\n\n\n\n\n\ncontact\nlatest version\nsource\n\n\n\n\nSebastian Weirich, Benjamin Becker\nCRAN page\nCRAN page\n\n\n\n\n\n\nDescription\nCalculates means, standard deviations, variances, frequency tables, percentiles and linear (logistic) regressions, as well as trends for all these analyses in clustered multilevel structures with imputed data. The package implements part of the functionality of the WesVar computer software in R and is mainly relevant for the IQB Bildungstrend studies.\n\n\n\n\n\nDocumentation\n\n\n\n\ninternal\n\n\ninternal\n\n\nReplication Analysis with eatRep\n\n\ninternal"
  },
  {
    "objectID": "docs/R/ws3.html",
    "href": "docs/R/ws3.html",
    "title": "Pakete(-Installation), Workspace, Daten laden und speichern in R",
    "section": "",
    "text": "Die Funktionalität von base R wird um ein vielfaches durch ein sehr umfangreiches Pakete-Universum ergänzt. Diese Erweiterungen werden für R packages oder libraries genannt. Im Prinzip kann jeder(r) eine solche library schreiben, deswegen ist bei der Nutzung neuer libraries etwas Vorsicht geboten. Es gibt jedoch eine Reihe sehr weit verbreiteter und hochwertiger libraries, deren Nutzung uneingeschränkt empfohlen werden kann.\nLiegen Pakete auf CRAN, können sie mithilfe von install.packages() installiert werden. Pakete, die ausschließlich auf Github verfügbar sind, können über devtools::install_github() installiert werden. Für nähere Informationen siehe auch: http://iqbstaff.pbworks.com/w/page/138429033/R-Pakete%20Installieren\n\n# Paket von CRAN installieren\ninstall.packages(\"car\")\n# Paket von Github installieren\nremotes::install_github(\"sachseka/eatPrep\", upgrade = \"never\")\n\nAchtung: Wenn ein Paket bereits geladen ist und eine Neuinstallation dieses Pakets versucht wird, kann dies zu Fehlern führen. In diesem Fall kann entweder die R Session neu gestartet oder das entsprechende Paket mit detach() “entladen” werden.\nZur Verwendung von Paketen können einzelne Funktionen explizit über ihren Namespace angesprochen werden, ohne dass sie dafür explizit geladen werden müssen:\n\n# Funktion verwenden, ohne Paket zu laden\nsome_data &lt;- c(1, 2, 1, 4)\ncar::recode(some_data, \"1 = 'a'; 2 = 'b'; 4 = 'd'\")\n\n[1] \"a\" \"b\" \"a\" \"d\"\n\n\nOder das Paket wird vollständig geladen mithilfe des library() Befehls\n\n# Paket laden\nlibrary(\"car\")\n\nLoading required package: carData\n\nsome_data &lt;- c(1, 2, 1, 4)\nrecode(some_data, \"1 = 'a'; 2 = 'b'; 4 = 'd'\")\n\n[1] \"a\" \"b\" \"a\" \"d\"\n\n\nFalls es mehrere Pakete gibt, die Funktionen mit demselben Namen beinhalten (zB dplyr::recode()), kann mit car::recode() sichergestellt werden, dass immer die gewünschte Funktion verwendet wird, auch wenn zusätzlich das Paket dplyr geladen wird."
  },
  {
    "objectID": "docs/R/ws3.html#csv",
    "href": "docs/R/ws3.html#csv",
    "title": "Pakete(-Installation), Workspace, Daten laden und speichern in R",
    "section": ".csv",
    "text": ".csv\nBeim Speichern von comma seperated files (.csv) können die Funktionen write.csv() und write.csv2() verwendet werden, wobei letztere Funktion den deutschen Excel-Konventionen (“,” als Dezimaltrenner) entspricht.\n\n# Objekt speichern\nwrite.csv2(mtcars, \"Material_WSIII/mtcars.csv\")\n# Objekt laden\ndat &lt;- read.csv2(\"Material_WSIII/mtcars.csv\")\n# Objekt betrachten\nhead(dat)"
  },
  {
    "objectID": "docs/R/ws3.html#xlsx-excel",
    "href": "docs/R/ws3.html#xlsx-excel",
    "title": "Pakete(-Installation), Workspace, Daten laden und speichern in R",
    "section": ".xlsx (Excel)",
    "text": ".xlsx (Excel)\nZum Einlesen von Excel files empfiehlt sich die Funktion read_xlsx() aus dem Paket readxl. Achtung! Da das Paket standardmäßig einen tibble ausgibt, eine Spezialform von data.frames, empfiehlt sich die Umwandlung zu einem data.frame. Da das Paket leider kein Schreiben von Excel files unterstützt, empfiehlt sich hierfür die Funktion write_xlsx() aus dem Paket eatAnalysis.\n\n# Objekt speichern\neatAnalysis::write_xlsx(mtcars, \"Material_WSIII/mtcars.xlsx\", row.names = FALSE)\n# Objekt laden\ndat &lt;- readxl::read_xlsx(\"Material_WSIII/mtcars.xlsx\")\ndat &lt;- as.data.frame(dat)\nhead(dat)"
  },
  {
    "objectID": "docs/R/ws3.html#sav-spss",
    "href": "docs/R/ws3.html#sav-spss",
    "title": "Pakete(-Installation), Workspace, Daten laden und speichern in R",
    "section": ".sav (SPSS)",
    "text": ".sav (SPSS)\nZum Importieren von SPSS-Dateien bietet sich das Paket eatGADS an. Es ermöglicht das Einlesen von Daten in einem zwei-schrittigem Vorgehen. Zuerst werden die Daten eingelesen.\n\n# sav Datei einlesen\nspss &lt;- eatGADS::import_spss(\"Material_WSIII/example.sav\")\n\nDiese Datei enthält sämtliche Metadaten, die auch die originale spss-Datei beinhaltet (Variablen- und Wertelabel etc.). Diese können mithilfe von extractMeta abgefragt werden. Im Folgenden werden die Metadaten für die Variable \"PJgsep_a\" abgerufen:\n\n# sav Datei einlesen\neatGADS::extractMeta(spss, \"PJgsep_a\")\n\nUm Analysen in R durchzuführen, müssen die Daten aus diesem Objekt nun mithilfe der extractData()-Funktion extrahiert werden. Diese ermöglicht zum einen Missingcodes anzuwenden, zum anderen gelabelte Variablen entweder als numerische, character oder Faktor-Variablen auszugeben.\n\n# sav Datei einlesen\ndat &lt;- eatGADS::extractData(spss, convertLabel = \"character\", convertMiss = TRUE)\nhead(dat)"
  },
  {
    "objectID": "docs/R/ws3.html#dta-stata",
    "href": "docs/R/ws3.html#dta-stata",
    "title": "Pakete(-Installation), Workspace, Daten laden und speichern in R",
    "section": ".dta (Stata)",
    "text": ".dta (Stata)\nStata-Datein können mithilfe des Paktes haven sowohl gelesen als auch geschrieben werden.\n\n# Objekt speichern\nhaven::write_dta(mtcars, \"Material_WSIII/mtcars.dta\")\n# Objekt laden\ndat &lt;- haven::read_dta(\"Material_WSIII/mtcars.dta\")\ndat &lt;- as.data.frame(dat)\nhead(dat)"
  },
  {
    "objectID": "docs/R/ws3.html#dat-mplus",
    "href": "docs/R/ws3.html#dat-mplus",
    "title": "Pakete(-Installation), Workspace, Daten laden und speichern in R",
    "section": ".dat (Mplus)",
    "text": ".dat (Mplus)\nHäufig möchte man in Vorbereitung von Analysen mithilfe von Mplus Daten in R aufbereiten. Das Paket MplusAutomation beinhaltet die Funktion prepareMplusData(), die das schreiben von .dat Datein ermöglicht und zusätzlich einen Rohling für die Mplus-Analysesyntax erstellt. Außerdem beinhaltet das Paket zahlreiche Möglichkeiten verschiedene Analysen zu automatisieren.\n\n# Objekt speichern\nMplusAutomation::prepareMplusData(mtcars, filename = \"Material_WSIII/mtcars.dat\")"
  },
  {
    "objectID": "docs/R/ws1.html",
    "href": "docs/R/ws1.html",
    "title": "R Workshop Einführung",
    "section": "",
    "text": "R ist eine Programmiersprache für Datenmanipulation, statistische Datenanalyse und grafische Darstellung von Daten (Yanada, 2018).\nDatenmanipulation:\n\nImport und Export: Einlesen und Schreiben von SPSS-, Excel-, ASCII- oder trennzeichenbasierten Dateien\nKopieren, verschieben, löschen, packen und entpacken von Dateien und Verzeichnissen\nVariablen- und Fallselektion, Rekodieren/Aggregieren von Variablen\nUmstrukturieren von Datensätzen (long/wide)\nManipulation von Zeichenketten (Verknüpfen, extrahieren, ersetzen, z.B. auch mithilfe regulärer Ausdrücke: sehr mächtig, aber zuweilen kompliziert)\n\nstatistische Datenanalyse:\n\nlineare und nichtlineare Regression\nVarianzanalyse\nStrukturgleichungsmodelle\nMehrebenenanalyse\nMultiple Imputation\nItem-Response-Modelle\ndecision trees\nmixed models, u.v.m.\n\ngrafische Darstellung von Daten:\n\nBoxplots\nHistogramme\nHeat Maps"
  },
  {
    "objectID": "docs/R/ws1.html#einleitung",
    "href": "docs/R/ws1.html#einleitung",
    "title": "R Workshop Einführung",
    "section": "",
    "text": "R ist eine Programmiersprache für Datenmanipulation, statistische Datenanalyse und grafische Darstellung von Daten (Yanada, 2018).\nDatenmanipulation:\n\nImport und Export: Einlesen und Schreiben von SPSS-, Excel-, ASCII- oder trennzeichenbasierten Dateien\nKopieren, verschieben, löschen, packen und entpacken von Dateien und Verzeichnissen\nVariablen- und Fallselektion, Rekodieren/Aggregieren von Variablen\nUmstrukturieren von Datensätzen (long/wide)\nManipulation von Zeichenketten (Verknüpfen, extrahieren, ersetzen, z.B. auch mithilfe regulärer Ausdrücke: sehr mächtig, aber zuweilen kompliziert)\n\nstatistische Datenanalyse:\n\nlineare und nichtlineare Regression\nVarianzanalyse\nStrukturgleichungsmodelle\nMehrebenenanalyse\nMultiple Imputation\nItem-Response-Modelle\ndecision trees\nmixed models, u.v.m.\n\ngrafische Darstellung von Daten:\n\nBoxplots\nHistogramme\nHeat Maps"
  },
  {
    "objectID": "docs/R/ws1.html#r-als-taschenrechner",
    "href": "docs/R/ws1.html#r-als-taschenrechner",
    "title": "R Workshop Einführung",
    "section": "2. R als Taschenrechner",
    "text": "2. R als Taschenrechner\nIn der R Konsole kann man (mathematische) Funktionen eingeben und sie evaluieren lassen. Im einfachsten Fall funktioniert das wie ein Taschenrechner.\n\n2+3\n\n[1] 5\n\n2*3\n\n[1] 6\n\n\nDas Dezimaltrennzeichen in R ist ein Punkt, kein Komma.\n\n5/4\n\n[1] 1.25\n\n\nExponentialschreibweise:\n\n2^3\n\n[1] 8\n\n\nObwohl es nicht so aussieht, werden bei diesen Operationen im Hintergrund Funktionen ausgeführt. So kann man sich beispielsweise die Wurzel aus 2 einfach in Exponentialschreibweise oder mithilfe der Wurzelfunktion ausgeben lassen:\n\n2^0.5\n\n[1] 1.414214\n\n\nWurzelfunktion:\n\nsqrt(2)\n\n[1] 1.414214\n\n\nAllgemein gilt auch in R: “Punktrechnung vor Strichrechnung”:\n\n2*3+1\n\n[1] 7\n\n2*(3+1)\n\n[1] 8"
  },
  {
    "objectID": "docs/R/ws1.html#grundlagen",
    "href": "docs/R/ws1.html#grundlagen",
    "title": "R Workshop Einführung",
    "section": "3. Grundlagen",
    "text": "3. Grundlagen\nR ist zugleich eine Sprache und eine Umgebung für statistische Datenbearbeitung. R ist objektbasiert. Alles in R ist ein Objekt: Zahlen, Vektoren, Matrizen, Funktionen. Das grundlegende Funktionsprinzip ist dabei: “Definiere ein Objekt und weise ihm einen Wert zu.” Im einfachsten Fall wird im folgenden Beispiel das Objekt b erzeugt und ihm der Wert 2 zugewiesen. Um sich den Wert von b anzeigen zu lassen, kann man b einfach in die Konsole tippen:\n\nb &lt;- 2\nb\n\n[1] 2\n\n\nb** ist nun intern gespeichert und kann ebenfalls für Zuweisungen benutzt werden. Hier wird ein neues Objekt d erzeugt und ihm als Wert die Quadratwurzel von b zugewiesen:\n\nd &lt;- sqrt(b)\n\nMöglich ist es auch, b wieder mit einem anderen Wert zu überschreiben:\n\nb &lt;- 100 * b\nb\n\n[1] 200\n\n\nMit dem Befehl class kann man sich die Klasse von b anzeigen lassen.\n\nclass(b)\n\n[1] \"numeric\"\n\n\nDie wichtigsten Klassen für skalare Objekt (also solche, die nur aus einem einzigen Element bestehen), sind\n\nnumeric: reelle Ziffer oder Zahlen\ncharacter: Zeichenkette\nlogical: logischer Wert, der nur zwei Zustände annehmen kann, TRUE oder FALSE\n\nIm folgenden verschiedene Beispiele für character- bzw. logische Zuweisungen, hier jeweils wiederum nur für die Länge 1. Zuweisungen der Klasse character erfolgen mit hochgestellten Anführungszeichen:\n\nd &lt;- \"hallo\"\nclass(d)\n\n[1] \"character\"\n\nlength(d)\n\n[1] 1\n\n\nWenn einem Objekt die Zahl 220 in hochgestellten Anführungszeichen zugewiesen wird, wird der Wert nicht als numerisch, sondern als character behandelt:\n\ne &lt;- \"220\"\nclass(e)\n\n[1] \"character\"\n\n\nWenn einem Objekt der Austruck TRUE in hochgestellten Anführungszeichen zugewiesen wird, wird der Wert nicht als logical, sondern als character behandelt:\n\nf &lt;- TRUE\nclass(f)\n\n[1] \"logical\"\n\ng &lt;- \"TRUE\"\nclass(g)\n\n[1] \"character\"\n\n\n\n3.1 Vektoren\nVektoren sind definiert als eine Reihe von Elementen derselben Klasse. Sie können unter anderem mit der Funktion c() erzeugt werden:\n\na &lt;- c(1,4,2,2,89)\nb &lt;- c(\"gut\", \"schlecht\")\nd &lt;- c(TRUE, TRUE, TRUE, FALSE, TRUE, TRUE)\n\nÄhnlich wie in den vorher aufgeführten Beispielen kann man sich mit verschiedenen Befehlen verschiedene Eigenschaften dieser Vektoren zeigen lassen, etwa ihre Länge (= die Anzahl ihrer Elemente) mit length(), oder ihre Klasse mit class(). Bestimmte Funktionen wiederum kann man sinnvoll nur für numerische Vektoren anweden (z.B. sum(), mean(), min(), max() etc. Andere wiederum sind nur für Vektoren der Klasse character sinnvoll, etwa nchar(), das einem die Anzahl der Zeichen einer Zeichenkette gibt. Ganz allgemein gilt: Funktionen, die man auf Skalare anwenden kann, kann man in der Regel auch auf Vektoren anwenden:\n\nskalar &lt;- 2\nsqrt(skalar)\n\n[1] 1.414214\n\nvektor &lt;- c(1,4,2,2,89)\nsqrt(vektor)\n\n[1] 1.000000 2.000000 1.414214 1.414214 9.433981\n\n\nDie Funktion sqrt gibt dabei genauso viele Elemente zurück, wie der Vektor besitzt, den man der Funktion übergeben hat. Das ist nicht bei allen Funktionen so; die mean-Funktion gibt (sinnvollerweise) immer nur ein Element zurück.\n\nskalar &lt;- 2\nmean(skalar)\n\n[1] 2\n\nvektor &lt;- c(1,4,2,2,89)\nmean(vektor)\n\n[1] 19.6\n\n\nWas passiert, wenn man Vektoren “unzulässig” definiert, also beispielsweise die Regel, dass alle Elemente dieselbe Klasse haben müssen, missachtet? Vektoren werden in die “kleinste gemeinsame Klasse” umgewandelt. Es gibt hier keine Warnmeldung, und manchmal führt das zu unerwünschten Nebenwirkungen. Zuerst betrachten wir einen Vektor, der aus Elementen der Klasse numeric, character und logical besteht:\n\nb &lt;- c(1,6,\"hallo\",TRUE,11,FALSE)\nb\n\n[1] \"1\"     \"6\"     \"hallo\" \"TRUE\"  \"11\"    \"FALSE\"\n\n\nDer gesamte Vektor wird als character definiert:\n\nclass(b)\n\n[1] \"character\"\n\n\nBesteht der Vektor nur aus Elementen der Klassen numeric und logical, wird der Vektor als numeric definiert:\n\nb &lt;- c(1,6,TRUE,11,FALSE)\nb\n\n[1]  1  6  1 11  0\n\nclass(b)\n\n[1] \"numeric\"\n\n\nAn diesen Bespielen erkennt man prototypisch, wie R sich bei “widersinnigen” Benutzereingaben verhält: Anstatt bei formal falschen oder unsinnigen Eingaben wie nchar(15) eine Fehlermeldung auszugeben, wird versucht zu “antizipieren”, was der Benutzer gemeint oder beabsichtigt haben könnte. Bei nchar(15) wird also zunächst der numerische Ausdruck in einen character-Ausdruck umgewandelt und anschließend die Anzahl der Zeichen dieses Ausdrucks ausgegeben. Intern wertet R statt nchar(15) folgenden Ausdruck aus: nchar(\"15\") bzw. nchar(as.character(15)). Ein solches oder ähnliches Verhalten wendet R in unzähligen Fällen an, und daraus ergeben sich zugleich Vor- und Nachteile: es erlaubt dem Anwender, syntaktisch “unsauberen” Code zu verwenden, ohne dass es zu Fehlermeldungen kommt. In der Regel erhält man das gewünschte Ergebnis. Außerdem kann man R-Syntaxen teils sehr sparsam und “schreibfaul” erstellen; nchar(15) ist ja viel kürzer als nchar(as.character(15)). Dass R diese Nachlässigkeiten erlaubt, hat aber auch Nachteile: die syntaktische Logik der R-Sprache ist dadurch weniger transparent, und falls es doch zu Fehlermeldungen kommt, sind diese erstmal weniger verständlich.\nAlternative Möglichkeiten, Vektoren zu erzeugen. Alle Zahlen von 1 bis 20:\n\na &lt;- 1:20\n\nErzeuge eine Zahlenreihe von -2 bis +2 in Intervallen von 0.2:\n\na &lt;- seq(-2,2,0.2) \n\nRepliziere die Ziffer 4 dreimal:\n\na &lt;- rep(4,3)\n\nRepliziere die Zahlenfolge von 1 bis 4 dreimal:\n\na &lt;- rep(1:4,3)\n\nRepliziere in der Zahlenfolge von 1 bis 4 jede einzelne Ziffer dreimal:\n\na &lt;- rep(1:4,each=3)\n\nRepliziere in der Zahlenfolge von 1 bis 4 jede einzelne Ziffer dreimal, und repliziere den egsamten Vektor zweimal:\n\na &lt;- rep(1:4,each=3, times = 2)\n\nRepliziere in der Zahlenfolge von 1 bis 4 die 1 einmal, die 2 zweimal, die 3 dreimal, etc.:\n\na &lt;- rep(1:4,1:4)\n\n\n\n3.2 Navigation in Vektoren (subsetting)\nMithilfe eckiger Klammern kann man sich einzelne Elemente eines Vektors anzeigen lassen oder auch verändern.\n\nb &lt;- sqrt(1:5)\n\nDer gesamte Vektor b besteht aus fünf Zahlen:\n\nb\n\n[1] 1.000000 1.414214 1.732051 2.000000 2.236068\n\n\nMit b[2] kann man sich nur das zweite Element des Vektors anzeigen lassen; mit b[2] &lt;- 1000 kann man das zweite Element durch die Zahl 1000 ersetzen:\n\nb[2] &lt;- 1000\nb\n\n[1]    1.000000 1000.000000    1.732051    2.000000    2.236068\n\n\nMit b[4:5] &lt;- c(400, 500) kann man das vierte und fünfte Element durch die Zahlen 400 und 500 ersetzen:\n\nb[4:5] &lt;- c(400, 500)\nb\n\n[1]    1.000000 1000.000000    1.732051  400.000000  500.000000\n\n\nHier ein weiteres Beispiel für ein syntaktisch “fehlerhaftes” Subsetting, das trotzdem funktioniert. Man würde erwarten, dass b[4:5] &lt;- 45 eine Fehlermeldung gibt: zwei Elemente in einem Vektor sollen durch eine Zahl ersetzt werden. Die “sauberere” Lösung wäre b[4:5] &lt;- c(45, 45). Dennoch funktionier auch b[4:5] &lt;- 45:\n\nb[4:5] &lt;- 45\nb\n\n[1]    1.000000 1000.000000    1.732051   45.000000   45.000000\n\n\nWeitere “unzulässige” Operationen haben wieder denselben Effekt wie oben beschrieben. Ersetze ich ein Element des numerischen Vektors durch ein character-Element, wird der gesamte Vektor ebenfalls nach character umgewandelt.\n\nb[1] &lt;- \"hallo\"\nclass(b)\n\n[1] \"character\"\n\nb\n\n[1] \"hallo\"            \"1000\"             \"1.73205080756888\" \"45\"              \n[5] \"45\"              \n\n\n\n\n3.3 Funktionsliste I: Deskriptive Statistiken für numerische Vektoren\nAlle Funktionen, die sich sinnvoll auf numerische Vektoren anwenden lassen, können hier in ihrer Vollständigkeit nicht aufgeführt werden. Im Folgenden sollen jedoch die gebräuchlichsten und am häufigsten verwendeten aufgelistet werden:\n\nsum(). Berechnet die Summe aller Elemente eines Vektors. Nicht definiert für nicht-numerische Vektoren.\nmean(). Arithmetischer Mittelwert aller Elemente eines Vektors. Nicht definiert für nicht-numerische Vektoren.\nsd(). Standardabweichung\nvar(). Varianz\nmin(). Minimum\nmax(). Maximum\nscale(). Funktion zum Zentrieren oder z-Standardisieren. Die Funktion besitzt zusätzliche Argumente, je nachdem ob standardisiert oder nur zentriert werden soll. Für die zusätzlichen Argumente sind Standardeinstellungen (defaults) definiert – also “Voreinstellungen” der Argumente, die benutzt werden, wenn der Anwender die Funktionsargumente selbst nicht explizit definiert. Ein Vektor a &lt;- rnorm(100, mean = 2, sd = 8) mit Mittelwert 2 und Standardabweichung 8 wird mit scale(a, center = TRUE, scale = FALSE) zentriert und mit scale(a, center = TRUE, scale = TRUE) standardisiert. (Bei scale(a, center = FALSE, scale = FALSE) passiert einfach gar nichts; der Vektor wird 1:1 so zurückgegeben, wie er war.)\ntable() gibt eine Häufigkeitsverteilung aller Werte eines Vektors. Das ist sowohl für numerische als auch für nicht-numerische Vektoren möglich und für letztere häufig sinnvoller.\nsort(). Elemente auf- oder absteigend sortieren. Geht auch für nicht-numerische Vektoren (bei character-Vektoren wird in diesem Fall sortiert, bei Faktoren nach Ordnung der factor levels). Auch sort() enthält zusätzliche Argumente mit Voreinstellungen, z.B. das Argument decreasing, das angibt, ob auf- oder absteigend sortiert werden soll. Der default ist hier decreasing = FALSE; es wird also standardmäßig aufsteigend sortiert.\norder() funktioniert ähnlich wie sort(), gibt aber anstelle des Vektor-Wertes die Position zurück. Am einfachsten lässt sich das mit einem character-Vektor veranschaulichen – hier erkennt man auch, dass verschiedene R-Funktionen zueinander häufig redundant sind; es gibt verschiedene syntaktische Möglichkeiten, ein und dasselbe Ergebnis zu erhalten. Das macht R zum einen recht flexibel, zum anderen nicht unbedingt übersichtlich.\n\n\nvek &lt;- c(\"oh\", \"je\", \"mi\", \"neh\")\nsort(vek)\n\n[1] \"je\"  \"mi\"  \"neh\" \"oh\" \n\norder(vek)\n\n[1] 2 3 4 1\n\nvek[order(vek)]\n\n[1] \"je\"  \"mi\"  \"neh\" \"oh\" \n\n\n\nrev() kehrt die Reihenfolge der Elemente eines Vektors um\nunique() zeigt die Elemente des Vektors und lässt alle mehrfach vorhandenen Werte aus.\nduplicated() gibt einen logischen Vektor zurück, der für jedes Element anzeigt, ob es einzigartig ist (FALSE) oder mindestens zweimal vorkommt (TRUE)\nwhich() gibt zurück, an welcher Stelle (oder welchen Stellen) eines Vektors sich ein bestimmtes Element befindet, z.B. which(x == 5), oder eine bestimmte Bedingung erfüllt ist which(x &gt; 5), oder which(x != 5)\n\nDas sind, wie gesagt, bei weitem nicht alle Funktionen für numerische Vektoren. Wenn man eine bestimmte Operation durchführen möchte und den R-Befehl nicht kennt, hilft es häufig, die gewünschte Operation bei Google mit dem Zusatz “R” oder “R CRAN” einzugeben, vorzugsweise in englisch, z.B. “R sort by more than one variable”.\n\n\n3.4 Funktionsliste II: Bearbeiten von character-Vektoren\nIm Anwendungsfall von Large-scale Assessments im Bildungsforschungsbereich kommen character-Vektoren bspw. in Variablen- oder Itemnamen vor. Weniger häufig begegnet man ihnen unter anderem auch in Freitextfeldern in Schülerfragebögen. R bietet zahlreiche Möglichkeiten zur Bearbeitung von character-Vektoren, die auch reguläre Ausdrücke einschließen. Hier sollen nur die wichtigsten anhand prominenter Anwendungsfälle genannt werden. Man könnte sich beispielsweise vorstellen, in einem großen Datensatz mit vielen Variablen bestimmte Spalten oder Variablen identifizieren beziehungsweise verändern zu wollen. Der beispielhaft verwendete Vektor mit Variablennamen sei der folgende:\n\nvarnamen &lt;- c(\"idstud\", \"idclass\", \"D10101a\", \"D10102a\", \"D10102b\", \"D10103a\", \"D10201a\", \"D10301\", \"sex\", \"M15511a\", \"M15612a\", \"M15712b\", \"M15712c\", \"M15712d\", \"hisced\", \"parid\")\n\nInsgesamt gibt es hier nur 14 Variablen – in großen Large-scale Datensätzen hat man es ja zuweilen mit 1000 variablen und mehr zu tun.\n\nDie Funktion grep()\ngrep() erlaubt, einen character-vektor nach einem bestimmten Muster zu durchsuchen. Zurückgegeben werden alle Positionen, an denen dieses Muster auftritt. Man kann sich das ein bisschen wie die Suchfunktion in Word vorstellen. grep() hat verschiedene Argumente – pattern gibt das Muster an, was gesucht werden soll, x gibt den character-Vektor an, in dem gesucht werden soll, und value gibt als logisches Argument an, ob der Wert selbst oder seine Position zurückgegeben werden soll. Die Flexibilität von grep() rührt unter anderem auch daher, dass man als Suchmuster (pattern) auch reguläre Ausdrücke verwenden kann.\n\ngrep(pattern=\"id\", x=varnamen) findet die Positionen der Variablennamen, die ein “id” im Variablennamen haben.\ngrep(pattern=\"id\", x=varnamen, value=TRUE) zeigt die Variablennamen an, die ein “id” im Variablennamen haben.\ngrep(pattern=\"^id\", x=varnamen, value=TRUE) zeigt die Variablennamen an, die mit einem “id” im Variablennamen beginnen. (Der “Haken” vor dem “id” besagt, dass der Variablenname mit “id” beginnen muss)\nWenn ich id-Variablen finden will, mit aber nicht sicher bin, ob die in dem Datensatz groß oder klein geschrieben sind, ich aber im Zweifel beide haben will, kann man die “Oder”-verknüpfung nehmen (genaueres im Abschnitt “Logische Operatoren”): grep(pattern=\"ID|id\", x=varnamen, value=TRUE)\nAuch den letzten Befehl kann man “einengen”, dass nur die Variablennamen gesucht werden sollen, die mit einem groß oder kleingeschriebenen “ID” beginnen: grep(pattern=\"^ID|^id\", x=varnamen, value=TRUE)\nDas ist auch sinnvoll, wenn ich beispielsweise alle Variablennamen der Deutsch-Items identifizieren will und weiß, Deutsch-Items beginnen mit einem groß geschriebenen “D”: grep(pattern=\"^D\", x=varnamen, value=TRUE)\nGenauso kann man auch nur die Variablennamen suchen, die mit einem klein geschriebenen “a” aufhören: grep(pattern=\"a$\", x=varnamen, value=TRUE). Das “$”-Zeichen gibt an, dass nach dem Zeichen “a” der Variablenname zuende sein muss.\nMöglich (aber etwas komplizierter) sind auch Verknüpfungen der Art: Finde alle Variablennamen, die mit einem “D” beginnen und einem “a” aufhören. Hier handelt es sich um eine logische Verknüpfung zweier Bedingungen – genauer wird darauf im folgenden Abschnitt “Logische Operatoren” eingegangen. In R kann man das auf verschiedenen Wegen realisieren; eine Möglichkeit soll hier kurz demonstriert werden:\n\n\nbeginnt_mit_D &lt;- grep(pattern=\"^D\", x=varnamen, value=TRUE)\nendet_mit_a   &lt;- grep(pattern=\"a$\", x=varnamen, value=TRUE)\nbeides        &lt;- intersect(beginnt_mit_D, endet_mit_a)\nbeides\n\n[1] \"D10101a\" \"D10102a\" \"D10103a\" \"D10201a\"\n\n\n\n\nDie Funktionen gsub(), substr(), substring(), nchar() und strsplit()\n\ngsub() erlaubt es, Teile eines character-Vektors zu ersetzen. Sollen bspw. in der Variablenliste alle Namen, die mit “D101” beginnen, durch “D201” ersetzt werden, geht das mit gsub(pattern = \"D101\", replacement = \"D201\", x = varnamen). Hier ist es wichtig, die Stelligkeit zu beachten; gsub(pattern = \"D1\", replacement = \"D2\", x = varnamen) würde auch z.B. “D102” durch “D202” ersetzen. Möglich, aber nicht notwendig ist hier auch, die Ersetzung nur durchzuführen, wenn “D101” am Anfang des strings steht: gsub(pattern = \"^D101\", replacement = \"D201\", x = varnamen).\nsubstr() erlaubt es, bestimmte Teile eines character-Vektors “auszuschneiden”: wenn man bspw. nur die ersten 4 Zeichen ausschneiden will, geht das mit substr(x = varnamen, start = 1, stop = 4). Zeichenketten mit weniger als 4 Zeichen (hier etwa der Variablenname “sex”) werden dabei so beibehalten, wie sie waren.\nMöchte man von dem character-Vektor nur am Anfang bspw. das erste Zeichen entfernen und alle anderen beibehalten (egal, wie viele es sind), bietet sich die Funktion substring() an: substring(text = varnamen, first = 2)\nnchar() einem für jedes Element die Anzahl von Zeichen (Buchstaben und Ziffern): nchar(varnamen)\nstrsplit() teilt einen character-Vektor an einem definierten Zeichen\n\n\n\nDie Funktion paste()\nDie Funktion erlaubt es, character-Vektoren aus einzelnen Elementen “zusammenzubauen”. Soll beispielsweise an den Variablennamens-Vektor varnamen das Jahr der Erhebung mit angefügt werden, geht das mit folgendem Ausdruck: paste(varnamen, \"2012\", sep=\"_\"). An jeden Variablennamen wurde nun die Jahreszahl 2012 angefügt. Der Argument sep gibt dabei das Zeichen an, das als “Trenner” zweischen dem ursprünglichen Ausdruck und dem “Suffix” 2012 verwendet werden soll. paste() ist eine recht mächtige Funktion, so kann man bspw. auch an jeden Variablennamen die laufende Nummer anhängen, die er im character-Vektor einnimmt: paste(varnamen, 1:length(varnamen), sep=\"_\"). Es ist auch möglich, alle Elemente des Vektor zu einem einzigen großen String zusammenzubinden: paste(varnamen, collapse=\"_\"). Die wichtige, aber häufig Verwirrung stiftende Unterscheidung liegt hierbei zwischen den Separationsargumenten sep und collapse. sep definiert das Trennzeichen für die einzelnen Terme; collapse (ggf.) das Trennzeichen, mit dem die Ergebnisse zusammengefügt werden (sofern sie zusammengefügt werden sollen). Die Hilfeseite der paste-Funktion liefert einige anschauliche Beispiele, die die Unterscheidung zwischen beiden verdeutlichen.\n\n\nFunktionen aus eatTools\nIm Laufe der Datenaufbereitungsprozeduren am IQB wurden die obenstehenden Funktionen teils erweitert. Ohne Anspruch auf Vollständigkeit sollen weitere Möglichkeiten der Zeichenkettenmanipulation kurz genannt werden:\n\neatTools::crop() entfernt führende oder abschließende Leerzeichen (bzw. ein frei definiertes Zeichen) aus einem character-Vektor. Das ist bspw. dann sinnvoll, wenn in inakkurat aufbereiteten Datensätzen z.B. anstatt einer 1 der Wert 1 (also mit einem unbeabsichtrigten leerzeichen eingetragen wurde. Hier werden (nur der Anschaulichkeit zuliebe) alle führenden und abschließenden “D”s aus den Variablennamen entfernt: eatTools::crop(varnamen, char = \"D\")\neatTools::removeNumeric() entfernt alle Ziffern aus einem character-Vektor: eatTools::removeNumeric(varnamen)\neatTools::removeNonNumeric() entfernt alle Buchstaben aus einem character-Vektor und lässt nur die Ziffern übrig. Manche Elemente von varnamen sind hinterher leer. eatTools::removeNonNumeric(varnamen)\neatTools::removePattern() entfernt ein bestimmtes Muster aus einem character-Vektor: eatTools::removePattern(string = varnamen, pattern = \"id\")"
  },
  {
    "objectID": "docs/R/ws1.html#logische-operatoren",
    "href": "docs/R/ws1.html#logische-operatoren",
    "title": "R Workshop Einführung",
    "section": "4. Logische Operatoren",
    "text": "4. Logische Operatoren\nAllgemeines zu logischen Operatoren kann man auf der gleichnamigen Wikipediaseite finden: https://de.wikipedia.org/wiki/Logischer_Operator\nFür sämtliche Operatoren gibt es eine Entsprechung in R. Die Syntax ist dabei (weitgehend) äquivalent zu den angegeben Beispielen für C, C++, Java und PHP auf der Wikipediaseite. Der Wahrheitswert, der in R zurückgegeben wird, hat die Klasse logical und kann 2 Werte annehmen: TRUE oder FALSE. Der Wahrheitswert kann wiederum einem Objekt zugewiesen werden:\n\nistWahr &lt;- 4 == 5 \nclass(istWahr)\n\n[1] \"logical\"\n\nistWahr\n\n[1] FALSE\n\n\n\nLogische Operatoren ohne Verknüpfung\n\nist größer als: 4 &gt; 3\nist kleiner als: 4 &lt; 3\nist größer oder gleich: 4 &gt;= 3\nist kleiner oder gleich: 4 &lt;= 3\nist gleich: 4 == 3\nist ungleich: 4 != 3\n\n\n\nLogische Operatoren mit Verknüpfungen\n\nBedingung a UND Bedingung b sind erfüllt: 4 &gt; 3 & is.numeric(5)\nBedingung a ODER Bedingung b ist erfüllt: 4 &gt; 3 | is.numeric(5)\nENTWEDER Bedingung a ODER Bedingung b ist erfüllt: xor(4 &gt; 3, is.numeric(5)). Hier wird FALSE zurückgegeben, da beide Bedingungen erfüllt sind, und eben nicht nur entweder a oder b.\nBedingung b ist nicht erfüllt: !is.numeric(\"a\"). Hier wird TRUE zurückgegeben, denn es ist ja wahr, dass “a” nicht numerisch ist.\n\n\n\nArbeiten mit vektorwertigen logischen Verknüpfungen\nIn den oberen Beispielen wurden logische Abfragen immer nur für ein Objekt der Länge 1 durchgeführt. Man kann diese Funktionen aber auch auf Vektoren anwenden. Dazu folgendes hypothetisches Beispiel: ein großer Datensatz mit vielen Variablen soll in Mplus ausgewertet werden. In Mplus dürfen Variablennamen jedoch nur maximal 6 Zeichen haben. Gibt es also in dem Variablennamens-Vektor varnamen Variablennamen mit unerlaubter Länge? Um das zu prüfen, geht man in mehreren Schritten vor:\n\nZeige für jedes Element im Variablennamens-Vektor die Anzahl von Buchstaben an.\n\n\nanzahl &lt;- nchar(varnamen)\n\n\nPrüfe, für welche Variablennamen die zulässige Zeichenanzahl überschritten ist. Dazu wird ein logischer Vektor erzeugt, der den Wert TRUE annimmt, wenn die Zeichenanzahl maximal 6 beträgt, andernfalls FALSE.\n\n\nerlaubt &lt;- anzahl &lt;= 6\nerlaubt\n\n [1]  TRUE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE  TRUE FALSE FALSE FALSE\n[13] FALSE FALSE  TRUE  TRUE\n\n\n\nNun wird geprüft, ob diese Bedingung für alle Variablennamen erfüllt ist. Dazu können die Funktionen all() oder any() benutzt werden. all() fragt: Haben alle Elemente des Vektors erlaubt den Wahrheitswert TRUE? any() fragt: Gibt es irgendein Element in dem Vektors erlaubt, das den Wahrheitswert FALSE hat?\n\n\nall(erlaubt)\n\n[1] FALSE\n\nany(erlaubt == FALSE)\n\n[1] TRUE\n\n\n\nJa, einige Variablennamen haben eine größere Zeichenanzahl als 6. Man kann die Variablennamen auf die ersten 6 Zeichen reduzieren:\n\n\nvarnamen_neu &lt;- substr(varnamen, 1, 6)\n\n\nVariablennamen müssen jedoch stets einzigartig (unique) sein. Ist das jetzt noch der Fall? Dazu verwendet man die oben beschriebene Funktion duplicated() in Verbindung mit any:\n\n\nany(duplicated(varnamen_neu))\n\n[1] TRUE\n\n\nDer Wahrheitswert ist TRUE, es gibt also mindestens zwei Variablennamen, die jetzt identisch sind. An dieser Stelle könnte es passieren, dass man erstmal nicht weiter weiß. Eine Möglichkeit wäre, zu googlen: “r make unique”. So findet man eine Funktion namens make.unique, die es erlaubt, duplizierte Werte in character-Vektoren zu ersetzen, so dass sie einzigartig werden. Unglücklicherweise werden dadurch die Variablennamen wieder länger, als sie sein dürfen:\n\nvarnamen_neu2 &lt;- make.unique(varnamen_neu)\nany(nchar(varnamen_neu2)&gt;6)\n\n[1] TRUE\n\n\nTatsächlich gibt es für dieses Problem also keine einfache, “triviale” Lösung. Man könnte entweder vollständig willkürliche Namen vergeben, die dann aber keine Rückschlüsse auf die ursprüngliche Variablenbedeutung mehr zulassen, oder man experimentiert, beruhend auf folgenden Überlegungen: make.unique fügt an nicht-unique Variablennamen einen Punkt und eine laufende Nummer an, also zwei zusätzliche Zeichen. Also dürfte man nur die ersten 4 Zeichen der Variablennamen beibehalten:\n\nvarnamen_neu3 &lt;- make.unique(substr(varnamen, 1, 4))\nany(nchar(varnamen_neu3)&gt;6)\n\n[1] FALSE\n\nany(duplicated(varnamen_neu3))\n\n[1] FALSE\n\nvarnamen_neu3\n\n [1] \"idst\"   \"idcl\"   \"D101\"   \"D101.1\" \"D101.2\" \"D101.3\" \"D102\"   \"D103\"  \n [9] \"sex\"    \"M155\"   \"M156\"   \"M157\"   \"M157.1\" \"M157.2\" \"hisc\"   \"pari\"  \n\n\nHundertprotentig schön ist auch diese Variante nicht, weil nun auch von bereits einzigartigen Variablennamen nur die ersten vier Zeichen übrig behalten worden sind, obwohl es hier ja hätten sechs sein dürfen. Sofern eine solche Operation im Arbeitsalltag also häufiger gebraucht wird, wäre es günstig, sich dafür eine eigene Funktion zu schreiben, um diese Prozesse weniger umständlich zu gestalten. Dazu aber an anderer Stelle mehr."
  },
  {
    "objectID": "docs/R/ws1.html#fehlende-werte-missing-values",
    "href": "docs/R/ws1.html#fehlende-werte-missing-values",
    "title": "R Workshop Einführung",
    "section": "5. Fehlende Werte (missing values)",
    "text": "5. Fehlende Werte (missing values)\nFehlende Werte werden in R mit NA (not available) gekennzeichnet. Im Folgenden geht es nicht darum, wie in statistischen Analysen mit fehlenden Werten umgegangen werden kann, sondern wie man sie in R technisch behandelt. Dazu soll beispielhaft ein numerischer Vektor betrachtet werden, der fehlende Werte enthält:\n\nnumvek &lt;- rnorm(20, 0, 1)\nnumvek[c(3,6,9,19)] &lt;- NA\n\n\nDie häufigsten im Zusammenhang mit fehlenden Werten gebräuchlichen Funktionen sind:\n\nis.na() gibt einen Vektor der Klasse logical zurück, dessen Wert TRUE ist, wenn es sich um einen fehlenden Wert handelt: is.na(numvek). Wenn man lediglich wissen, ob es überhaupt irgendwelche fehlenden Werte gibt, kann man das mit any() verbinden: any(is.na(numvek)). Wenn man wissen will, an welcher Stelle die fehlenden Werte stehen, geht which(is.na(numvek))\nAchtung! Anders als man vielleicht vermuten würde, funktioniert which(numvek == NA) nicht!\nWenn ich nur die beobachteten Werte aus numvek extrahieren möchte, also alles ausschließen, was NA ist, geht das mit na.omit(numvek). Dieser Vektor ist mit nur noch 16 Elementen folglich kürzer als der ursprüngliche mit 20 Elementen: length(na.omit(numvek))\nMöchte man sich beispielsweise den Mittelwert eines Vektors anzeigen lassen, der fehlende Werte enthält, ist das Ergebnis ebenfalls NA: mean(numvek). Meist will man jedoch einfach das arithmetisches Mittel aller beobachteten Werte. Dazu könnte man einfach den Mittelwert unter Ausschluss der fehlenden Werte bestimmen: mean(na.omit(numvek)). Das ist dasselbe, wie wenn man in der Funktion mean() mit einem zusätzlichen Argument definiert, dass fehlende Werte vor der Berechnung ausgeschlossen werden sollen: mean(numvek, na.rm = TRUE). Man sieht wieder, dass verschiedene syntaktische Umsetzungen zu dem gewünschten Ergebnis führen können. Das logische Argument na.rm ist für viele Funktionen definiert, so etwa var(), sd(), lm(), glm(), etc.\n\n\n\nFehlende Werte in character-Vektoren\nHier gilt im Grunde dasselbe wie für numerische Vektoren. Auf ein paar Fallstricke soll hingewiesen werden:\n\ncharvek &lt;- c(\"France\", \"Belgium\", \"Poland\", NA, \"Denmark\", \"NA\", \"Austria\", \"\")\nwhich(is.na(charvek))\n\n[1] 4\n\n\nAuch in character-Vektoren müssen fehlende Werte ohne hochgestellte Anführungszeichen eingetragen werden; der sechste Wert \"NA\" wird nicht als fehlender Wert verstanden. Ebensowenig der achte Wert, der einfach ein leerer String ist. Letzteres ist insofern relevant, dass, wenn man etwa csv-Dateien mit R einliest, leere Zellen manchmal als leere Strings eingelesen werden, obwohl man sie eigentlich wie fehlende Werte behandelt wissen will. Um das \"NA\" und den leeren String in einen wirklichen fehlenden Wert umzuwandeln, kann beispielsweise die recode()-Funktion aus dem Paket car verwendet werden:\n\ncharvek_neu &lt;- car::recode(charvek, \"'NA'=NA; ''=NA\")\ncharvek_neu\n\n[1] \"France\"  \"Belgium\" \"Poland\"  NA        \"Denmark\" NA        \"Austria\"\n[8] NA"
  },
  {
    "objectID": "docs/R/ws1.html#gut-zu-wissen",
    "href": "docs/R/ws1.html#gut-zu-wissen",
    "title": "R Workshop Einführung",
    "section": "6. Gut zu wissen",
    "text": "6. Gut zu wissen\nDen Überblick über die vorhandenen Funktionen und Pakete zu behalten, ist nahezu unmöglich; allein auf CRAN gibt es tausende von R-Paketen. Aus unserer subjektiven Sicht sollen daher die wichtigsten Funktionen, die sich im Laufe des IQB-Lebens als unverzichtbar herausgestellt haben, hier kurz ohne Anspruch auf Vollständigkeit aufgelistet werden. Wo nötig, werden Links für weiterführende Literatur angegeben:"
  }
]